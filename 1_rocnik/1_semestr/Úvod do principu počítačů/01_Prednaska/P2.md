# Kódování dat a odolnost proti chybám

Aby počítač mohl zpracovávat jakákoliv data (text, obrázky, čísla), musí být nejprve převedena do formátu, kterému rozumí – do **binární soustavy**. Tento proces se nazývá kódování.

---

## Reprezentace dat v počítači 

> [!abstract] Co je to kód?
> Kód je pravidlo (zobrazení), které každému objektu z jedné množiny (např. písmenům abecedy) jednoznačně přiřadí prvek z druhé množiny – tzv. **kódové slovo** (např. řetězec nul a jedniček).
> 
> `{ objekty } → { kódová slova }`

V počítačích se používají **binární kódy**, kde kódovými slovy jsou řetězce složené pouze z bitů (0 a 1).

### Kolik slov lze vytvořit?
Pokud mají všechna kódová slova stejnou délku *n* bitů, můžeme vytvořit $2^n$ různých unikátních kódových slov.

> [!example] Příklad
> Pro **n = 8 bitů** (1 bajt) můžeme vytvořit $2^8 = 256$ různých kódových slov. To stačí například pro reprezentaci všech znaků v tabulce ASCII.

| Délka kódového slova | Počet bitů (n) | Počet různých kódových slov |
| :------------------- | :------------- | :-------------------------- |
| 1 bit                | 1              | $2^1 = 2$                   |
| 1 půlbyte (nibble)   | 4              | $2^4 = 16$                  |
| 1 byte               | 8              | $2^8 = 256$                 |
| 2 byty               | 16             | $2^{16} = 65 536$           |
| 4 byty               | 32             | $2^{32} = 4 294 967 296$    |
|                      | $n$            | $2^n$                       |

---

## Hammingova vzdálenost 

Binární kódová slova si můžeme představit jako vrcholy v *n*-rozměrném prostoru (hyperkrychli). Hammingova vzdálenost nám říká, jak "daleko" jsou od sebe dva takové vrcholy.

> [!abstract] Definice Hammingovy vzdálenosti
> Pro dvě kódová slova $X$ a $Y$ stejné délky *n* je Hammingova vzdálenost $d(X, Y)$ definována jako **počet pozic, na kterých se jejich bity liší**.
> $$
> d(X, Y) = \sum_{i=1}^{n} |x_i - y_i|
> $$

-   **Geometricky:** Je to nejkratší počet hran, po kterých musíme projít, abychom se dostali z vrcholu X do vrcholu Y.

> [!example] Příklad
> Mějme slova $X = (011)$ a $Y = (110)$.
> - Liší se na první pozici (`0` vs `1`) a na třetí pozici (`1` vs `0`).
> - Jejich Hammingova vzdálenost je tedy **d = 2**.

### Minimální kódová vzdálenost ($d_{min}$)
Toto je nejdůležitější parametr celého kódu. Je to **nejmenší Hammingova vzdálenost** nalezená mezi všemi možnými páry různých kódových slov v daném kódu.

$$
d_{min} = \min_{\substack{X_i, X_j \in K \\ i \neq j}} d(X_i, X_j)
$$

> [!important]
> Hodnota $d_{min}$ přímo určuje schopnost kódu **detekovat** a **opravovat** chyby, které vznikají například při přenosu dat.

---

## Rozdělení kódů podle odolnosti proti chybám 

Podle hodnoty $d_{min}$ můžeme kódy rozdělit do tří kategorií:

### 1. Základní kód
> [!note] Podmínka: $d_{min} \ge 1$
> Zajišťuje pouze to, že každé kódové slovo je unikátní. **Nemá žádnou schopnost detekce ani opravy chyb.**

### 2. Zabezpečující kód (detekce chyb)
> [!warning] Podmínka: $d_{min} \ge 2$
> Kód dokáže spolehlivě **detekovat** (odhalit) až $t$ chyb, kde platí:
> $$
> t = d_{min} - 1
> $$
> **Princip:** Pokud při přenosu vznikne méně než $d_{min}$ chyb, přijaté slovo nebude odpovídat žádnému platnému kódovému slovu. Víme, že nastala chyba, ale nevíme jaká.

### 3. Samoopravný kód (oprava chyb)
> [!success] Podmínka: $d_{min} \ge 3$
> Kód dokáže spolehlivě **opravit** až $t$ chyb, kde platí:
> $$
> t = \left\lfloor \frac{d_{min} - 1}{2} \right\rfloor
> $$
> **Princip:** I poškozené slovo je stále "blíže" svému originálu než jakémukoli jinému platnému slovu. Dekodér tak může jednoznačně určit původní slovo a chybu opravit.

### Souhrnná tabulka

| Typ kódu      | Minimální vzdálenost ($d_{min}$) | Maximální počet **detekovatelných** chyb | Maximální počet **opravitelných** chyb |
| :------------ | :-----------------------------: | :-------------------------------------: | :-----------------------------------: |
| **Základní** | $\ge 1$                         | 0                                       | 0                                     |
| **Zabezpečující** | $\ge 2$                         | $d_{min} - 1$                           | 0                                     |
| **Samoopravný** | $\ge 3$                         | $d_{min} - 1$                           | $\lfloor (d_{min}-1)/2 \rfloor$      |

# Konstrukce zabezpečujícího kódu pomocí paritního bitu

Základní kódy, které mají minimální vzdálenost **$d_{min} = 1$**, nedokáží detekovat žádné chyby. Jejich schopnosti můžeme jednoduše vylepšit rozšířením o takzvaný **paritní bit**. Tímto mechanismem zvýšíme minimální vzdálenost kódu na $d_{min} = 2$, čímž získáme **zabezpečující kód** schopný detekovat jednu chybu.

---

## Princip paritního bitu

> [!abstract] Definice
> Původní kódové slovo $X = (x_1, x_2, \dots, x_n)$ rozšíříme o jeden přidaný bit, **paritní bit $p$**. Tím vytvoříme nové, delší kódové slovo:
> $$
> X' = (x_1, x_2, \dots, x_n, p)
> $$
> Hodnota bitu $p$ se vypočítá tak, aby celkový počet jedniček v novém slově $X'$ splňoval předem dané pravidlo (paritu).

Existují dva základní typy parity:

### 1. Lichá parita (Odd Parity)
> [!note] Cíl: Celkový počet jedniček v novém slově $X'$ musí být **lichý**.
> Paritní bit $p$ se vypočítá pomocí operace XOR (exkluzivní součet) všech bitů původního slova a konstanty 1:
> $$
> p = x_1 \oplus x_2 \oplus \dots \oplus x_n \oplus 1
> $$

### 2. Sudá parita (Even Parity)
> [!note] Cíl: Celkový počet jedniček v novém slově $X'$ musí být **sudý**.
> Paritní bit $p$ se vypočítá jako XOR všech bitů původního slova:
> $$
> p = x_1 \oplus x_2 \oplus \dots \oplus x_n
> $$

---

### Příklad v praxi

Mějme původní kódové slovo **X = (1011)**. Počet jedniček je 3 (lichý).

-   **Pro lichou paritu:**
    - Chceme, aby celkový počet jedniček zůstal lichý (3, 5, ...).
    - Musíme tedy přidat $p=0$.
    - Nové kódové slovo je **$X' = (10110)$**. Počet jedniček je 3.

-   **Pro sudou paritu:**
    - Chceme, aby celkový počet jedniček byl sudý (2, 4, ...).
    - Musíme tedy přidat $p=1$.
    - Nové kódové slovo je **$X' = (10111)$**. Počet jedniček je 4.

> [!success] Výsledek
> Pokud se při přenosu slova $X'=(10111)$ změní jeden bit (např. na $10**0**11$), přijímač okamžitě zjistí, že parita nesedí (počet jedniček je 3, což není sudé), a tím **detekuje chybu**.


# Konstrukce samoopravného kódu (Hammingovy kódy)

Cílem je vytvořit kód, který dokáže nejen detekovat, ale i **opravit jednu chybu**. Toho dosáhneme, pokud bude minimální vzdálenost mezi všemi platnými kódovými slovy **$d_{min} = 3$**.

---

## Postup konstrukce

1.  **Vycházíme z dat:** Máme zprávu, která se skládá z **`m` datových bitů** ($d_1, d_2, \dots, d_m$). Samotná tato zpráva má $d_{min} = 1$.

2.  **Přidáme kontrolní bity:** Kód rozšíříme o **`k` paritních (kontrolních) bitů** ($p_1, p_2, \dots, p_k$).

3.  **Vznikne nové kódové slovo:** Výsledné slovo má celkovou délku **`m + k`** bitů a je složeno z původních datových a nově přidaných paritních bitů.

---

## Klíčová podmínka (Hammingova nerovnost)

Aby kód mohl opravit jednu chybu, musí počet paritních bitů `k` stačit k zakódování informace o tom, **na které pozici** v celém slově chyba nastala, plus jeden stav pro případ, že **žádná chyba nenastala**.

> [!important] Podmínka pro samoopravný kód
> Počet datových bitů `m` a paritních bitů `k` musí splňovat následující nerovnost:
> $$
> m + k + 1 \le 2^k
> $$

### Vysvětlení nerovnosti:
-   **$m + k$**: Počet pozic v kódovém slově, na kterých může nastat chyba.
-   **$+ 1$**: Představuje stav, kdy k žádné chybě nedošlo.
-   **$m + k + 1$**: Celkový počet stavů, které potřebujeme rozlišit (chyba na 1. bitu, chyba na 2. bitu, ..., žádná chyba).
-   **$2^k$**: Celkový počet informací (stavů), které můžeme zakódovat pomocí `k` paritních bitů.

Paritní bity musí mít dostatečnou "kapacitu" ($2^k$), aby dokázaly pokrýt všechny možné případy chyb a bezchybný stav ($m+k+1$).

> [!example] Příklad
> Chceme přenést **m = 4** datové bity (např. `1011`). Kolik paritních bitů `k` potřebujeme k vytvoření samoopravného kódu?
>
> -   Zkusíme **k = 2**:
>     $4 + 2 + 1 \le 2^2 \implies 7 \le 4$  ... **Nevyhovuje.**
> -   Zkusíme **k = 3**:
>     $4 + 3 + 1 \le 2^3 \implies 8 \le 8$  ... **Vyhovuje!**
>
> Pro 4 datové bity tedy potřebujeme 3 paritní bity. Vytvoříme tak kódové slovo o celkové délce 7 bitů (známý jako Hammingův kód H(7,4)).


# Hammingův kód – Konstrukce a princip

Hammingův kód je typ **samoopravného kódu**, který dokáže detekovat až dvě chyby a **opravit jednu chybu**. Proto se označuje jako **SEC** (Single Error Correcting). Jeho klíčovou vlastností je minimální vzdálenost **$d_{min} = 3$**.

---

## 1. Uspořádání datových a paritních bitů

Nejprve je nutné správně uspořádat datové bity ($d_1 \dots d_m$) a paritní bity ($p_1 \dots p_k$) do výsledného kódového slova.

> [!abstract] Pravidla pro uspořádání
> 1.  **Paritní bity ($p$)** se umisťují na pozice, jejichž číslo je **mocninou dvou** (1, 2, 4, 8, 16, …).
> 2.  **Datové bity ($d$)** se postupně vloží na **všechny zbývající volné pozice**.

Výsledné uspořádání kódového slova tedy vypadá takto:
`p₁ p₂ d₁ p₄ d₂ d₃ d₄ p₈ d₅ d₆ d₇ d₈ ...`
nebo podle indexů:
`1(p) 2(p) 3(d) 4(p) 5(d) 6(d) 7(d) 8(p) 9(d) ...`

---

## 2. Výpočet paritních bitů

Každý paritní bit "kontroluje" specifickou skupinu bitů (včetně sebe sama) v celém kódovém slově. Které bity kontroluje, je dáno jeho vlastní pozicí.

> [!info] Princip kontroly
> Pozice paritního bitu určuje, kterou sekvenci bitů bude kontrolovat. Podíváme se na binární reprezentaci pozic všech bitů v kódovém slově. Paritní bit $p_i$ (na pozici $2^{i-1}$) kontroluje všechny bity, jejichž číslo pozice má na *i*-té pozici v binárním zápisu jedničku.
>
> **Jednodušší pravidlo:**
> -   **p₁ (pozice 1):** Kontroluje všechny bity na pozicích 1, 3, 5, 7, 9, 11, … (přeskakuje po jednom: vezmi 1, přeskoč 1, vezmi 1...).
> -   **p₂ (pozice 2):** Kontroluje všechny bity na pozicích 2, 3, 6, 7, 10, 11, … (přeskakuje po dvou: vezmi 2, přeskoč 2, vezmi 2...).
> -   **p₄ (pozice 4):** Kontroluje všechny bity na pozicích 4, 5, 6, 7, 12, 13, 14, 15, … (přeskakuje po čtyřech: vezmi 4, přeskoč 4, vezmi 4...).
> -   **p₈ (pozice 8):** Kontroluje bity 8-15, 24-31, atd.

Hodnota každého paritního bitu se pak vypočítá jako **XOR** všech datových bitů, které kontroluje. Cílem je obvykle dosáhnout **sudé parity** pro každou kontrolovanou skupinu.

> [!example] Příklad pro H(7,4) – data `1011`
> 1.  **Uspořádání:** Máme 4 datové bity ($d_1=1, d_2=0, d_3=1, d_4=1$) a potřebujeme 3 paritní bity ($p_1, p_2, p_4$).
>     `_ _ 1 _ 0 1 1` (pozice 1-7)
>     `p₁ p₂ d₁ p₄ d₂ d₃ d₄`
>
> 2.  **Výpočet paritních bitů (pro sudou paritu):**
>     -   **p₁** kontroluje pozice 3, 5, 7 (d₁, d₂, d₄) -> `1 ⊕ 0 ⊕ 1 = 0`. Tedy **p₁ = 0**.
>     -   **p₂** kontroluje pozice 3, 6, 7 (d₁, d₃, d₄) -> `1 ⊕ 1 ⊕ 1 = 1`. Tedy **p₂ = 1**.
>     -   **p₄** kontroluje pozice 5, 6, 7 (d₂, d₃, d₄) -> `0 ⊕ 1 ⊕ 1 = 0`. Tedy **p₄ = 0**.
>
> 3.  **Výsledné kódové slovo:** `0110011`

Tento postup zajistí, že pokud dojde k jedné chybě, poruší se právě ta kombinace paritních bitů, jejíž součet pozic ukáže přesně na místo chyby.



# Konstrukce Hammingova kódu: Příklad (8,4)

Tento příklad ukazuje, jak vytvořit samoopravný Hammingův kód pro zprávu, která má **m = 8 datových bitů**.

---

## 1. Určení počtu paritních bitů (k)

Nejprve musíme zjistit, kolik paritních (kontrolních) bitů potřebujeme k zabezpečení 8 datových bitů. K tomu použijeme Hammingovu nerovnost.

> [!important] Hammingova nerovnost
> Počet paritních bitů `k` musí být dostatečně velký, aby dokázal pokrýt všechny možné stavy (chyba na kterékoli z `m+k` pozic + stav bez chyby).
> $$
> m + k + 1 \le 2^k
> $$

Pro **m = 8**:
-   Zkusíme **k = 3**:
    $8 + 3 + 1 \le 2^3 \implies 12 \le 8$ ... **❌ Nevyhovuje.**
-   Zkusíme **k = 4**:
    $8 + 4 + 1 \le 2^4 \implies 13 \le 16$ ... **✅ Vyhovuje!**

Potřebujeme tedy **4 paritní bity**. Výsledné kódové slovo bude mít celkovou délku $m+k = 8+4 = 12$ bitů.

---

## 2. Výpočet hodnot paritních bitů

Každý paritní bit je vypočítán jako **XOR (⊕)** z pečlivě vybrané skupiny datových bitů. Které datové bity se použijí pro výpočet, závisí na pozici paritního bitu.

> [!info] Princip kontroly
> Paritní bit na pozici $2^n$ (tedy $p_1, p_2, p_4, p_8$) kontroluje všechny datové bity na pozicích, jejichž číslo pozice má v binárním zápisu na $(n+1)$-tém místě jedničku.

Pro přehlednost použijeme standardní značení paritních bitů podle jejich pozice ($p_1, p_2, p_4, p_8$).

#### **Paritní bit $p_1$ (pozice 1)**
-   Kontroluje všechny bity na lichých pozicích (3, 5, 7, 9, 11).
-   To odpovídá datovým bitům **$d_1, d_2, d_4, d_5, d_7$**.
-   $$ p_1 = d_1 \oplus d_2 \oplus d_4 \oplus d_5 \oplus d_7 $$

#### **Paritní bit $p_2$ (pozice 2)**
-   Kontroluje bity na pozicích 3, 6, 7, 10, 11.
-   To odpovídá datovým bitům **$d_1, d_3, d_4, d_6, d_7$**.
-   $$ p_2 = d_1 \oplus d_3 \oplus d_4 \oplus d_6 \oplus d_7 $$

#### **Paritní bit $p_4$ (pozice 4)**
-   *Na slidu označen jako $p_3$.*
-   Kontroluje bity na pozicích 5, 6, 7, 12.
-   To odpovídá datovým bitům **$d_2, d_3, d_4, d_8$**.
-   $$ p_4 = d_2 \oplus d_3 \oplus d_4 \oplus d_8 $$

#### **Paritní bit $p_8$ (pozice 8)**
-   *Na slidu označen jako $p_4$.*
-   Kontroluje bity na pozicích 9, 10, 11, 12.
-   To odpovídá datovým bitům **$d_5, d_6, d_7, d_8$**.
-   $$ p_8 = d_5 \oplus d_6 \oplus d_7 \oplus d_8 $$

Tento systém výpočtu zajišťuje, že pokud dojde k jednobitové chybě, kombinace chybných paritních kontrol jednoznačně identifikuje pozici této chyby.


# Princip zabezpečení dat SEC kódem 

**SEC (Single Error Correcting)** kódy, jako je Hammingův kód, jsou navrženy tak, aby dokázaly automaticky **opravit chybu v jednom bitu**. Následující diagram a popis vysvětlují, jak tento proces funguje v praxi, například při ukládání dat do paměti.

---

## Proces kódování a opravy chyby

![[Pasted image 20251013132437.png]]


Celý mechanismus lze rozdělit do dvou fází: zápis (kódování) a čtení (kontrola a oprava).

#### 1. Fáze: Zápis dat do paměti
-   Pro původní **datové bity ($d_1...d_8$)** se v **generátoru parity** vypočítají příslušné **paritní bity ($p_1...p_4$)**.
-   Do hlavní paměti se uloží kompletní kódové slovo, které obsahuje jak původní data, tak vypočítané paritní bity.

#### 2. Fáze: Čtení dat z paměti
-   Z paměti se načtou datové bity ($d'_1...d'_8$) a paritní bity ($p'_1...p'_4$). Během uložení mohlo dojít k chybě, proto je značíme čárkou.
-   Ze načtených datových bitů ($d'$) se v druhém generátoru parity **znovu vypočítá** sada kontrolních paritních bitů.
-   **Komparátor** porovná původní (načtené) paritní bity s těmi nově vypočítanými.
-   Výsledek porovnání je tzv. **syndrom**:
    -   **Nulový syndrom:** Všechny paritní kontroly sedí. Data jsou v pořádku.
    -   **Nenulový syndrom:** Kontroly nesedí. Hodnota syndromu přesně odpovídá **pozici chybného bitu**.
-   **Korektor** na základě nenulového syndromu provede opravu – jednoduše **otočí (zneguju) bit na chybné pozici**.

---

## Omezení a vylepšení SEC kódu

### Co se stane při více chybách?
> [!warning] Problém dvou chyb
> Standardní SEC kód si sice skvěle poradí s jednou chybou, ale pokud nastanou **chyby ve dvou bitech**, korektor je **opraví špatně**. Syndrom bude ukazovat na třetí, zcela nevinný bit, který korektor otočí. Výsledkem budou data se třemi chybami místo původních dvou.

### Řešení: SEC DED kód 
Aby se předešlo chybné opravě, rozšiřuje se SEC kód na **SEC DED (Single Error Correcting, Double Error Detecting)** kód.

> [!success] Princip SEC DED
> K celému kódovému slovu (data + paritní bity) se přidá **jeden další bit celkové parity** (např. sudé). Tento bit kontroluje paritu celého slova.
> 
> Díky tomu dokáže systém rozlišit mezi jednou a dvěma chybami:
> 1.  **Jedna chyba:** Nesedí syndrom z Hammingova kódu **A ZÁROVEŇ** nesedí celková parita. **→ Systém chybu opraví.**
> 2.  **Dvě chyby:** Nesedí syndrom z Hammingova kódu, ale celková parita **SEDÍ** (dvě změny se navzájem vyruší). **→ Systém detekuje neopravitelnou chybu a opravu neprovede.** Místo toho nahlásí problém.

# Data v počítači 

Veškerá data, se kterými počítač pracuje, můžeme rozdělit do dvou základních kategorií podle jejich účelu: na data, která nesou informaci, a data, která říkají, co se s informacemi má dělat.

---

## 1. Informační data (Elementární datové typy)

> [!note]
> Jsou to data, která po správné interpretaci **přinášejí nějakou informaci**. Jedná se o základní stavební kameny, se kterými programy pracují.

Mezi základní informační data patří:

-    **Logické hodnoty:** Reprezentují pravdu nebo nepravdu (např. `true`/`false`, `1`/`0`).
-    **Znaky:** Jednotlivé symboly, jako jsou písmena, číslice nebo speciální znaky (např. 'A', '!', '5').
-    **Čísla:**
    -   **V pevné řádové čárce:** Používají se pro reprezentaci **celých čísel** (např. 10, -150, 0).
    -   **V pohyblivé (plovoucí) řádové čárce:** Používají se pro reprezentaci **reálných čísel** (např. 3.14, -0.0025).

---

## 2. Povelová data (Instrukce programu)

> [!important]
> Jsou to data, která **určují počítači (procesoru), jakým způsobem má zpracovávat informační data**. Jde v podstatě o samotný program – sérii příkazů, které procesor vykonává.

Například povelové dato může být instrukce "sečti dvě čísla" nebo "ulož tento znak do paměti".


# Kódování logických hodnot 

Logická hodnota představuje výsledek rozhodnutí, zda je něco **pravda**, nebo **nepravda**. Jde o nejzákladnější typ dat v informatice.

---

## Uložení v paměti 

I když logická hodnota nese pouze 1 bit informace, v praxi se pro její uložení používá více místa.

-   **Teoreticky:** K uložení by stačilo kódové slovo délky **1 bit**.
-   **V praxi:** Logická hodnota se obvykle ukládá do kódového slova o velikosti **1 bajtu (8 bitů)**. Důvodem je, že moderní procesory jsou optimalizovány pro práci s celými bajty, a přístup k jednotlivým bitům by byl pomalejší a složitější.

---

## Reprezentace hodnot

Samotné hodnoty `pravda` a `nepravda` jsou v paměti reprezentovány specifickými číselnými hodnotami.

### ❌ Nepravda (False)
-   Je reprezentována jako **logická 0**.
-   Vždy odpovídá kódovému slovu s **nulovou hodnotou**.
-   **Kódové slovo:** `0000 0000`

### ✅ Pravda (True)
-   Je reprezentována jako **logická 1**.
-   Může být reprezentována **jakoukoliv nenulovou hodnotou**.
-   **Příklad kódového slova:** `0000 0001`, `1111 1111`, `0101 0101` atd.

> [!important] Klíčový princip
> Při vyhodnocování logické hodnoty se počítač neptá "je to rovno 1?", ale ptá se "je to různé od 0?". To zjednodušuje mnoho operací.


# Reprezentace textu/znaků 

Každý **text** chápeme jako posloupnost jednotlivých znaků z nějaké abecedy (například latinky, azbuky atd.). Každý znak má svoji specifickou znakovou hodnotu, kterou počítač ukládá.

---

## Dvě složky uloženého textu

Při ukládání textu v moderních programech se ve skutečnosti ukládají dvě oddělené skupiny informací:

### 1. Informace o znacích (Prostý text)
> [!note]
> Toto je samotný obsah – sekvence znaků, které tvoří text. Například "Ahoj světe!".

### 2. Informace o formátování textu
> [!info]
> Toto jsou vizuální instrukce, které určují, jak má text vypadat. Patří sem například:
> - Velikost a typ písma (font)
> - Barva textu
> - Podtržení, kurzíva, tučné písmo
> - Zarovnání, řádkování atd.

---

> [!important] Zaměření na prostý text
> Způsob, jakým různé programy (Word, Google Docs, Pages) ukládají formátování, se výrazně liší a je často velmi komplexní. Z hlediska základních principů počítačů se proto budeme zabývat především tím, jak se ukládá **prostý text**, tedy samotné znaky.


# Znaky: Řídící a Grafické

Znaky, resp. jejich kódové hodnoty, můžeme rozdělit do dvou základních skupin podle jejich funkce a významu.

---

## 1. Řídící znaky (Control Characters) 

> [!note]
> **Řídící znak** je speciální znak, jehož účelem není zobrazení, ale **řízení zpracování** ostatních znakových hodnot.

-   Tyto znaky nemají žádnou viditelnou podobu, proto se označují jako tzv. **netisknutelné znaky**.
-   Slouží k formátování textu, řízení komunikace nebo ovládání zařízení (jako je tiskárna nebo terminál).
-   **Příklady:**
    -   **Nová řádka** (příkaz pro přesun na další řádek, typicky generován klávesou `Enter`).
    -   **Konec zprávy** (označuje konec datového bloku).
    -   **Tabulátor**.
    -   **Zvonek** (příkaz pro pípnutí).

---

## 2. Grafické znaky (Printable Characters) 

> [!info]
> **Grafický znak** má význam viditelného grafického symbolu.

-   Tyto znaky představují tzv. **vnější reprezentaci** dat, která je vhodná pro zobrazení na monitoru nebo pro tisk na tiskárně.
-   Jsou to všechny znaky, které běžně vidíme a píšeme.
-   **Příklady:**
    -   **Písmena:** `A`, `b`, `č`, `X`
    -   **Číslice:** `1`, `5`, `9`
    -   **Interpunkce:** `.`, `,`, `?`, `!`
    -   **Značky:** `@`, `#`, `€`, `$`

# Reprezentace prostého textu 

Uložení prostého textu v počítači probíhá ve třech základních krocích. Cílem je převést lidsky čitelný text na sérii nul a jedniček, kterým rozumí procesor.

---

## Princip reprezentace

> [!abstract] Postup uložení textu
> 1.  **Rozdělení na znaky:** Text se nejprve rozloží na posloupnost jednotlivých znaků.
> 2.  **Kódování (Převod na číslo):** Každý znak se pomocí speciální převodní tabulky (znakového kódu, např. ASCII nebo Unicode) převede na odpovídající číselnou hodnotu (kódové slovo).
>     -   `Znak → Číslo`
> 3.  **Převod do dvojkové soustavy:** Výsledné číslo se převede do binární (dvojkové) soustavy, což je finální podoba, v jaké je znak uložen v paměti počítače.
>     -   `Číslo → Binární číslo`

---

## Příklad: Uložení textu "AHOJ"

> [!example] Zpracování slova "AHOJ"
> **1. krok: Rozdělení na znaky**
> Text rozdělíme na jednotlivé znaky: `A`, `H`, `O`, `J`.
> 
> **2. krok: Kódování (převod na čísla dle ASCII tabulky)**
> Každému znaku přiřadíme jeho desítkovou hodnotu:
> -   `A` → `65`
> -   `H` → `72`
> -   `O` → `79`
> -   `J` → `74`
> 
> **3. krok: Převod do dvojkové soustavy**
> Každé číslo převedeme na 8bitové binární slovo:
> -   `65` → `01000001`
> -   `72` → `01001000`
> -   `79` → `01001111`
> -   `74` → `01001010`
> 
> **Výsledek:** Text "AHOJ" je v paměti počítače uložen jako sekvence bitů:
> `01000001 01001000 01001111 01001010`


# Kódování znakových hodnot: ASCII a Unicode

Pro převod znaků na čísla (a následně do binární podoby) používá většina programů jednu ze tří hlavních metod, které se historicky vyvíjely.

---

### 1. 7-bitový ASCII kód (1973)

> [!note] ASCII: American Standard Code for Information Interchange
> Jedná se o původní, základní standard pro kódování znaků.

-   **Velikost slova:** Pro každý znak používá **7-bitová** kódová slova.
-   **Kapacita:** Umožňuje zakódovat **128 různých znaků** ($2^7$).
-   **Obsah:** Zahrnuje anglickou abecedu (bez diakritiky), číslice, interpunkci a základní řídící znaky. Pro češtinu a jiné národní jazyky byl nedostatečný.

---

### 2. 8-bitový ASCII kód (Kódové stránky, 90. léta)

> [!info] Rozšíření pro národní jazyky
> S nástupem potřeby reprezentovat znaky s diakritikou (jako `č`, `ř`, `š`) byl ASCII kód rozšířen o jeden bit.

-   **Velikost slova:** Pro každý znak používá **8-bitová** kódová slova (1 bajt).
-   **Kapacita:** Umožňuje zakódovat **256 různých znaků** ($2^8$).
-   **Princip:** Prvních 128 znaků zůstalo stejných jako v 7-bitovém ASCII. Druhá polovina (znaky 128-255) byla využita pro národní abecedy. Problémem bylo, že existovalo mnoho různých "kódových stránek" (např. jiná pro češtinu, jiná pro azbuku), což vedlo k problémům s kompatibilitou.

---

### 3. Unicode (1991)

> [!success] Univerzální standard
> Unicode vznikl jako snaha vytvořit jednotný standard, který by dokázal reprezentovat všechny znaky všech světových jazyků.

-   **Velikost slova:** Používá kódová slova proměnlivé velikosti, typicky **1 až 4 bajty** (8 až 32 bitů).
-   **Kapacita:** Umožňuje zakódovat obrovské množství znaků (v době vzniku slidu cca 100 000, dnes již přes 140 000).
-   **Výhoda:** Odstraňuje problémy s nekompatibilitou kódových stránek a umožňuje v jednom textu kombinovat znaky z různých jazyků (např. latinku, řečtinu a čínské znaky). Dnes je to nejpoužívanější standard.


# 7-bitový ASCII kód

> [!note] ASCII: American Standard Code for Information Interchange
> 7-bitový ASCII je základní znaková sada, která definuje **128 unikátních kódů** (od 0 do 127) pro reprezentaci písmen, číslic, interpunkce a řídících znaků.

---

## Obsah a struktura tabulky

![[Pasted image 20251013133706.png]]

Tabulka ASCII obsahuje následující skupiny znaků:

-    **Písmena abecedy:** Velká (A-Z) a malá (a-z), avšak **bez diakritiky**.
-    **Číslice:** `0` až `9`.
-    **Větnou interpunkci:** Zahrnuje znaky jako čárka, tečka, vykřičník, otazník, závorky atd.
-    **Speciální znaky:** Různé symboly jako `@`, `&`, `#`, `$` a **mezera** (která má kód 32).
-    **Řídící znaky:** Netisknutelné znaky s kódy **0 až 31** a **127**. Tyto znaky slouží k ovládání zařízení, formátování textu a řízení přenosu dat (např. `CR` - Carriage Return, `LF` - Line Feed, `BEL` - Bell).

---

### Rozdělení kódů

| Rozsah kódů   | Typ znaků                     | Příklad                                          |     |
| :------------ | :---------------------------- | :----------------------------------------------- | --- |
| **0 - 31**    | Řídící znaky                  | `NUL`, `BEL`, `CR`, `LF`, `ESC`                  |     |
| **32 - 47**   | Mezera, interpunkce a symboly | ` ` (mezera), `!`, `"`, `#`, `$`                 |     |
| **48 - 57**   | Číslice                       | `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9` |     |
| **58 - 64**   | Další interpunkce a symboly   | `:`, `;`, `<`, `=`, `>`, `?`, `@`                |     |
| **65 - 90**   | Velká písmena abecedy         | `A`, `B`, `C`, ..., `Z`                          |     |
| **91 - 96**   | Další symboly                 | `[`, `\`, `]`, `^`, `_`, `` ` ``                 |     |
| **97 - 122**  | Malá písmena abecedy          | `a`, `b`, `c`, ..., `z`                          |     |
| **123 - 127** | Závorky a řídící znak         | `{`, `\|`, `}`, `~`, `DEL`                       |     |

# 7-bitový ASCII - Použití a limity

---

## Uložení v paměti 💾

> [!note] Princip uložení
> Tabulka ASCII definuje **128 unikátních znaků**, což přesně odpovídá počtu kombinací, které lze vytvořit pomocí **7 bitů** ($2^7 = 128$). Každý znak má tedy svůj 7bitový kód.

V moderních počítačích, které pracují s daty po celých bajtech, se k tomuto 7bitovému kódu v praxi přidává jedna nula na začátek. Tím se hodnota čísla nezmění, ale zajistí se, že každý znak je uložen přesně v **jednom bajtu (8 bitů)**.

**Příklad:** Znak 'A' má kód `1000001` (7 bitů). V paměti se uloží jako `01000001` (8 bitů).

---

## Omezení pro národní jazyky 🌍

> [!warning] Nedostatečnost pro jiné jazyky
> Zatímco pro anglicky psané texty je 7-bitová ASCII tabulka stále použitelná, pro většinu ostatních jazyků je **zcela nedostatečná**.

Hlavním problémem je, že **neobsahuje písmena s diakritikou**, jako jsou české háčky a čárky (`č`, `š`, `ř`, `é`, `á` atd.). To znemožňuje správný zápis českých a mnoha dalších textů. Právě tento limit vedl k vývoji 8bitových rozšíření a později standardu Unicode.


# 8-bitový ASCII – Kódové stránky

> [!note] Reakce na omezení 7-bitového ASCII
> S potřebou zapisovat texty v národních jazycích přišlo rozšíření 7-bitového ASCII na **8-bitové**. Tím se zdvojnásobil počet dostupných znaků z 128 na **256**, což umožnilo přidat písmena s diakritikou a další speciální symboly.

---

## Princip kódových stránek

Prvních 128 znaků (kódy 0-127) zůstalo stejných jako v původním ASCII standardu. Druhá polovina tabulky (kódy 128-255) byla využita pro národní znaky.

> [!warning] Problém: Jedno rozšíření nestačí
> Ani 128 nových pozic nebylo dostatečných pro pokrytí všech znaků všech světových jazyků. Bylo nemožné do jedné tabulky umístit například českou diakritiku, azbuku i řeckou abecedu zároveň.

Tento problém vedl ke vzniku různých **kódových stránek**. Každá kódová stránka je v podstatě jiná verze horní poloviny ASCII tabulky, určená pro specifický jazyk nebo skupinu jazyků.

**Příklad kódových stránek:**
-   **Latin-2 (ISO 8859-2):** Pro jazyky střední a východní Evropy, včetně češtiny.
-   **Windows-1250:** Podobná verze od Microsoftu pro stejnou jazykovou oblast.
-   **Windows-1251:** Pro jazyky používající azbuku.

> [!error] Důsledek: Problémy s kompatibilitou
> Pokud byl text vytvořen v jedné kódové stránce (např. Windows-1250) a zobrazen na systému, který očekával jinou (např. standardní západní Windows-1252), došlo ke špatné interpretaci znaků. To je příčinou známého jevu, kdy se místo českých znaků zobrazovaly nesmyslné symboly ("rozsypaný čaj").

![[Pasted image 20251013134136.png]]
*Ukázka horní poloviny ASCII tabulky v jedné z kódových stránek pro středoevropské jazyky.*



# 8-bitový ASCII – Použití a kódové stránky

V dnešní době převažuje používání dvou hlavních skupin kódových stránek, které rozšiřují původní 7-bitové ASCII pro potřeby národních jazyků.

---

## Dvě hlavní skupiny kódových stránek

> [!note]
> 1.  **ISO 8859-1 až ISO 8859-16 (LATIN1 – LATIN16):** Standardizovaná sada kódových stránek, často používaná například v operačním systému **Linux**.
> 2.  **Windows 1250 až Windows 1258:** Sada kódových stránek definovaná společností Microsoft, používaná v operačním systému **Windows**. V programech od Microsoftu se tyto stránky často souhrnně označují zkratkou **ANSI**.

---

## Princip a omezení

Každá kódová stránka je navržena tak, aby obsahovala znaky potřebné pro **jednu specifickou geografickou nebo jazykovou oblast**.

> [!example] Příklady
> -   **ISO 8859-1 (LATIN1):** Určena pro **západoevropské jazyky**, jako je francouzština, španělština, němčina atd.
> -   **ISO 8859-2 (LATIN2)** a **Windows 1250:** Obě tyto kódové stránky pokrývají všechny znaky potřebné pro **češtinu**.

> [!error] Klíčové problémy kódových stránek
> -   **Nemožnost kombinace:** V jednom textovém souboru **nelze použít více kódových stránek najednou**. To znemožňuje například psát česky a zároveň používat azbuku v jednom dokumentu.
> -   **Nejednoznačnost kódů:** Význam číselného kódu znaku **není absolutní**. Stejný kód (např. 230) může v jedné kódové stránce představovat znak `æ` a v jiné `š`. To je hlavní příčinou chybného zobrazování znaků ("rozsypaného čaje").

# Unicode: Univerzální znaková sada 🌍

Unicode vzniklo jako řešení problémů s nekompatibilitou 8-bitových kódových stránek. Cílem bylo vytvořit **jednotný standard**, který by pokryl všechny znaky všech světových jazyků.

> [!success] Klíčové vlastnosti Unicode
> - **Univerzálnost:** Tabulka Unicode obsahuje znaky **všech světových jazyků** (v současnosti přes 140 000 znaků).
> - **Flexibilita:** V jednom textu není problém kombinovat znaky z více jazyků najednou (např. češtinu, azbuku a japonštinu).

---

## Metody kódování: UTF

Samotný Unicode přiřazuje každému znaku unikátní číslo (code point). Pro převod tohoto čísla do finální dvojkové podoby se používají různé metody, které se označují jako **UTF (Unicode Transformation Format)**.

> [!info] Nejběžnější UTF metody
> - **UTF-8**
> - **UTF-16**
> - **UTF-32**
>
> Volba metody má přímý vliv na to, kolik bajtů zabere jeden znak v paměti. Pokud je někde uvedeno pouze obecné "Unicode" bez specifikace, často se tím myslí metoda UTF-16.

### Porovnání velikosti reprezentace znaku

| Metoda  | Velikost znaku                        | Klíčová vlastnost                                                               |
| :------ | :------------------------------------ | :------------------------------------------------------------------------------ |
| **UTF-8** | **1, 2, 3 nebo 4 bajty** | Velmi efektivní pro texty s převahou anglických znaků (ty zabírají jen 1 bajt). Nejpoužívanější na internetu. |
| **UTF-16**| **2 nebo 4 bajty** | Dobrý kompromis pro jazyky s velkým množstvím znaků. Standard v mnoha systémech (např. Windows, Java). |
| **UTF-32**| **Vždy 4 bajty** | Jednoduché zpracování (každý znak má stejnou délku), ale paměťově nejméně efektivní. |


# Srovnání kódování textu: Znakový repertoár 🔡

Volba metody kódování textu přímo určuje, jaký **znakový repertoár** (sadu dostupných znaků) můžeme v daném textu použít. Následující tabulka a popis shrnují klíčové rozdíly mezi ASCII, kódovými stránkami a Unicode.

---

### Přehled pokrytí znaků

| Znaková sada                                    | ASCII (Angličtina) | Kódová stránka (Jazyky z jedné oblasti) | Unicode (Všechny jazyky) |
| :---------------------------------------------- | :----------------: | :------------------------------------: | :---------------------: |
| **Základní latinka a symboly** (a-z, A-Z, 0-9, @) | ✅                 | ✅                                     | ✅                      |
| **Národní diakritika** (á, é, č, ř, ž, ß)         | ❌                 | ✅                                     | ✅                      |
| **Znaky ostatních jazyků** (Ж, ק, 字, ب)         | ❌                 | ❌                                     | ✅                      |

---

### Podrobnější vysvětlení

#### 1. ASCII 🇬🇧
> [!note]
> Pokrývá pouze **základní repertoár** znaků potřebný pro angličtinu. Obsahuje písmena bez diakritiky, číslice a základní symboly. Pro jakýkoli jiný jazyk je nedostatečný.

#### 2. Kódová stránka 🇨🇿🇩🇪🇫🇷
> [!info]
> Rozšiřuje ASCII o znaky potřebné pro **specifickou jazykovou nebo geografickou oblast**. Například kódová stránka pro střední Evropu (LATIN2) přidává české, slovenské a další znaky s diakritikou. Její limitací je, že **neumožňuje kombinovat znaky z různých oblastí** (např. češtinu a azbuku).

#### 3. Unicode 
> [!success]
> Je to **univerzální standard**, jehož cílem je pokrýt **všechny znaky všech současných i historických jazyků** světa. Umožňuje bezproblémově kombinovat v jednom textu například latinku, řečtinu, čínské znaky i emotikony. Dnes je to nejpoužívanější a doporučovaný standard.



# Použití kódování textu v praxi

Volba kódování textu se liší v závislosti na aplikaci, operačním systému nebo formátu souboru. Zde jsou některé běžné příklady.

---

###  Webové stránky

> [!info]
> Do roku 2007 bylo nejrozšířenějším kódováním pro webové stránky **ASCII**, respektive jeho 8-bitová rozšíření. Poté ho jako dominantní standard nahradil **Unicode ve variantě UTF-8**, které je dnes nejpoužívanějším kódováním na internetu.

---

###  Microsoft Word

Program Microsoft Word používá pro ukládání textu standard **Unicode**, ale konkrétní varianta se liší podle formátu souboru:

-   **\*.doc (starší formát):** Používá variantu **UTF-16**.
-   **\*.docx (novější formát, od verze 2007):** Používá modernější a paměťově efektivnější variantu **UTF-8**.

---

### Názvy souborů ve Windows

> [!note]
> Operační systém **Windows** používá pro ukládání názvů souborů a složek kódování **Unicode ve variantě UTF-16**. To umožňuje používat v názvech souborů znaky z různých jazyků bez omezení.

---

### Legacy programy a ANSI

> [!warning] Problémy se staršími programy
> Řada starších programů, a dokonce i některé systémové nástroje, stále jako výchozí používají staré **kódové stránky**.
>
> **Příklad:** Program **Poznámkový blok (



# Kódování celých čísel 

**Celá čísla** (čísla s pevnou řádovou čárkou) zahrnují jak kladná, tak i záporná celá čísla. Jejich uložení v počítači vyžaduje specifický přístup, zejména kvůli znaménku.

---

## Problém se znaménkem

> [!note]
> Binární čísla v počítači sama o sobě **nemají znaménko** (především `-`). Je proto nutné najít způsob, jak převést celá čísla (včetně záporných) na přirozená (nezáporná) čísla, která lze reprezentovat pomocí bitů.

Tento převod se řeší různými metodami (např. dvojkovým doplňkem), které efektivně mapují záporná čísla do horní poloviny dostupného číselného rozsahu.

---

## Velikost úložiště a rozsah hodnot 

Podle předpokládaného rozsahu hodnot se celá čísla ukládají do kódových slov o velikosti **1 až 4 bajty**. Velikost úložiště přímo ovlivňuje, jak velká čísla lze reprezentovat.

| Kódové slovo | Rozsah (jen kladná / unsigned) | Rozsah (kladná i záporná / signed) |
| :----------- | :----------------------------- | :--------------------------------- |
| **1 byte** | 0 až 255                       | -128 až 127                        |
| **2 byte** | 0 až 65 535                    | -32 768 až 32 767                  |
| **4 byte** | 0 až 4 294 967 295             | -2 147 483 648 až 2 147 483 647    |

> [!info] Všimněte si asymetrie
> U záporných čísel je rozsah vždy o jedno číslo větší "do mínusu" (např. -128 vs +127). To je dáno tím, že nula je považována za kladné číslo, což uvolňuje jednu pozici pro zápornou stranu.



# Doplňkový kód

Pro uložení **celých čísel** (kladných i záporných) se v počítačích nejčastěji používá metoda **doplňkového kódu**. Tento způsob efektivně převádí všechna celá čísla na nezáporná, která lze snadno reprezentovat v binární soustavě.

---

## Princip vytvoření doplňkového kódu

> [!abstract] Pravidla pro převod
> Pro původní číslo **X** a délku kódového slova **n** (např. 8 bitů) platí:
>
> 1.  Je-li číslo **X kladné nebo nula**, kódové slovo **X'** je rovno původnímu číslu:
>     $$ X' = X $$
> 2.  Je-li číslo **X záporné**, kódové slovo **X'** se vypočítá jako:
>     $$ X' = X + 2^n $$
> 3.  Výsledné desítkové číslo **X'** se následně převede do binární soustavy.

---

## Příklad (pro 8bitové slovo, n=8)

V tomto příkladu je $2^n = 2^8 = 256$.

| Původní číslo (X) | Výpočet X' (desítkově) | Kódové slovo X' (desítkově) | Kódové slovo X' (binárně) | Kódové slovo X' (hexadecimálně) |
| :---------------: | :----------------------------- | :------------------------: | :----------------------: | :---------------------------: |
| **0** | `X' = 0`                       | 0                          | `0000 0000`              | `00`                          |
| **53** | `X' = 53`                      | 53                         | `0011 0101`              | `35`                          |
| **-53** | `X' = -53 + 256`               | 203                        | `1100 1011`              | `CB`                          |

> [!info] Klíčová vlastnost
> Tento způsob kódování je velmi výhodný, protože aritmetické operace (zejména sčítání a odčítání) fungují stejně pro kladná i záporná čísla, což výrazně zjednodušuje návrh procesorů.


# Doplňkový kód – Vlastnosti a výpočet

Doplňkový kód má několik klíčových vlastností, které z něj dělají efektivní metodu pro reprezentaci celých čísel v počítačích.

---

## Vlastnosti doplňkového kódu

> [!note] Klíčové vlastnosti
> -   **Znaménkový bit:** První bit zleva (nejvyšší bit) funguje jako znaménkový bit.
>     -   U **nezáporného čísla** (včetně nuly) je hodnota tohoto bitu **0**.
>     -   U **záporného čísla** je hodnota tohoto bitu **1**.
> -   **Vhodnost pro aritmetiku:** Tento formát je navržen tak, aby sčítání a odčítání fungovalo stejně pro kladná i záporná čísla, což zjednodušuje návrh procesorů.

---

## Doplněk – Jak znegovat číslo

Doplněk `d(x)` k číslu `x` je definován jako jeho opačná hodnota (negace), tedy `d(x) = -x`. V binární soustavě ho získáme praktickým dvoukrokovým postupem.

> [!abstract] Postup výpočtu doplňku (dvojkový doplněk)
> 1.  **Inverze bitů (Jedničkový doplněk):** V binárním zápisu čísla `x` zaměníme všechny nuly za jedničky a všechny jedničky za nuly.
> 2.  **Přičtení jedničky:** K výsledku z prvního kroku binárně přičteme `1`.

> [!example] Příklad: Výpočet doplňku k číslu 53 (v 8 bitech)
> Chceme najít reprezentaci pro číslo **-53**.
>
> 1.  **Binární zápis čísla 53:**
>     `0011 0101`
> 2.  **Krok 1: Inverze bitů**
>     `1100 1010`
> 3.  **Krok 2: Přičtení jedničky**
>     `1100 1010 + 1 = 1100 1011`
>
> **Výsledek:** `1100 1011` je dvojkový doplňkový kód pro číslo **-53**.



# Sčítání dvou čísel v doplňkovém kódu

Velkou výhodou doplňkového kódu je, že sčítání funguje pro kladná i záporná čísla naprosto stejně jako standardní binární sčítání. Proces probíhá bit po bitu zprava doleva a využívá přenosu do dalšího řádu.

---

## Princip sčítání (bit po bitu)

> [!abstract] Vstupní data
> Mějme dvě **n-bitová** čísla A a B v doplňkovém kódu:
> -   $A = (a_{n-1} \dots a_1, a_0)$
> -   $B = (b_{n-1} \dots b_1, b_0)$

Výsledný součet **S** a **přenosy C** se vypočítají podle následujících pravidel:

#### 1. Výpočet přenosu (Carry)
Přenos $c_{i+1}$ do dalšího sloupce se určí na základě bitů $a_i$, $b_i$ a přenosu z předchozího sloupce $c_i$.

> [!note] Pravidla pro přenos
> -   Počáteční přenos **$c_0$ je vždy 0**.
> -   Pro každý další bit `i` (od 0 do n-1) platí:
>     -   Přenos **$c_{i+1} = 1$**, pokud jsou alespoň **dvě** z hodnot ($a_i, b_i, c_i$) rovny 1.
>     -   V opačném případě je přenos **$c_{i+1} = 0$**.

#### 2. Výpočet výsledného bitu součtu
Výsledný bit součtu $s_i$ se vypočítá jako **XOR** (exkluzivní součet) tří bitů: $a_i, b_i$ a přenosu $c_i$.

> [!info] Vzorec pro součet
> $$
> s_i = a_i \oplus b_i \oplus c_i
> $$

---

## Příklad: Sečtení 5 + (-3) ve 4 bitech

-   **A = 5** → `0101`
-   **B = -3** → `1101` (dvojkový doplněk k číslu 3)
-   Očekávaný výsledek: **2** → `0010`

| Pozice (i) | 3 | 2 | 1 | 0 |
| :--------- | :-: | :-: | :-: | :-: |
| Přenos C | **$c_4=1$** | $c_3=1$ | $c_2=0$ | $c_1=1$ | $c_0=0$ |
| Číslo A | | 0 | 1 | 0 | 1 |
| Číslo B | | 1 | 1 | 0 | 1 |
| **Součet S**| | **0** | **0** | **1** | **0** |

**Postup:**
1.  **i=0:** `1 + 1 + 0` = `0`, přenos $c_1=1$.
2.  **i=1:** `0 + 0 + 1` = `1`, přenos $c_2=0$.
3.  **i=2:** `1 + 1 + 0` = `0`, přenos $c_3=1$.
4.  **i=3:** `0 + 1 + 1` = `0`, přenos $c_4=1$.

Výsledný součet je **`0010`**, což je správná hodnota čísla 2. Přenos z posledního bitu ($c_4$) se při sčítání v doplňkovém kódu ignoruje (pokud neřešíme přetečení).


# Sčítání v doplňkovém kódu: Výsledek a přetečení ➕

Po výpočtu přenosových bitů ($c_i$) můžeme sestavit finální výsledek a ověřit jeho platnost.

---

## Výpočet výsledného součtu (S)

[cite_start]Výsledný binární řetězec $S = (s_{n-1} \dots s_1, s_0)$ získáme tak, že pro každý bit `i` provedeme operaci **XOR** (exkluzivní součet) mezi odpovídajícími bity sčítanců ($a_i, b_i$) a přenosem z předchozího řádu ($c_i$). [cite: 1]

> [!abstract] Vzorec pro výpočet bitů součtu
> $$
> s_i = a_i \oplus b_i \oplus c_i
> $$

---

## Validační kritérium: Detekce přetečení (Overflow) ⚠️

Ne vždy se výsledek sčítání vejde do daného počtu bitů. [cite_start]Tento stav se nazývá **přetečení (overflow)** a znamená, že výsledné číslo `S` je neplatné. [cite: 1] K jeho detekci slouží validační kritérium.

> [!important] Pravidlo pro detekci přetečení
> [cite_start]Přetečení nastane, pokud se přenos **do** posledního (znaménkového) bitu **liší** od přenosu **z** posledního bitu. [cite: 1]
>
> Vypočítáme hodnotu `v` porovnáním dvou posledních přenosových bitů:
> $$
> v = c_n \oplus c_{n-1}
> $$
> Kde:
> [cite_start]-   **$c_{n-1}$** je přenos *do* posledního bitu. [cite: 1]
> [cite_start]-   **$c_n$** je přenos *z* posledního bitu. [cite: 1]
>
> **Vyhodnocení:**
> -   Pokud je **$v = 1$**, došlo k **přetečení**. [cite_start]Výsledek `S` je neplatný. [cite: 1]
> [cite_start]-   Pokud je **$v = 0$**, je výsledek `S` **platný** a vyjadřuje správný součet `A + B`. [cite: 1]

> [!example] Příklad: 4 + 5 ve 4 bitech
> -   **A = 4** → `0100`
> -   **B = 5** → `0101`
> -   Výsledek sčítání: `1001` (což je -7, tedy špatně)
> -   **Přenosy:**
>     -   $c_3$ (přenos *do* posledního bitu) = 1
>     -   $c_4$ (přenos *z* posledního bitu) = 0
> -   **Validace:** $v = c_4 \oplus c_3 = 0 \oplus 1 = 1$.
> -   **Závěr:** Došlo k přetečení, výsledek je neplatný.



# Násobení čísla mocninou dvojky (Bitový posun) 

Násobení libovolného čísla **X** k-tou mocninou dvojky ($2^k$) je v binární soustavě velmi efektivní a rychlá operace. Místo složitého aritmetického výpočtu se provádí jednoduchým **bitovým posunem doleva**.

---

## Princip násobení

> [!abstract] Postup
> 1.  Binární řetězec čísla **X** se posune o **k-míst doleva**.
> 2.  Na uvolněná místa zprava se vždy doplní hodnota **0**.

Výsledkem je číslo **S**, které odpovídá součinu $S = X \cdot 2^k$.

---

## Příklad: Násobení číslem 4 ($k=2$)

> [!example]
> Chceme vynásobit číslo **X** číslem 4, což je $2^2$. Budeme tedy posouvat o **k=2** místa doleva.
>
> **Původní číslo X:**
> `... xₙ₋₂  xₙ₋₃  ...  x₂  x₁  x₀`
>
> **Výsledné číslo S (posunuto o 2 místa doleva):**
> `... xₙ₋₂  xₙ₋₃  ...  x₂  x₁  x₀  0  0`
>
> Původní bity se posunuly a zprava se doplnily dvě nuly.

> [!info] Proč to funguje?
> V binární soustavě má každý bit váhu, která je mocninou dvou. Posunem celého čísla o jednu pozici doleva se váha každého bitu zdvojnásobí, což odpovídá násobení dvěma. Když tento posun provedeme *k*-krát, výsledek je stejný jako násobení číslem $2^k$.

# Dělení čísla k-tou mocninou dvojky (Bitový posun) 

Podobně jako násobení, i dělení čísla **X** k-tou mocninou dvojky ($2^k$) lze v binární soustavě provést velmi efektivně pomocí **bitového posunu doprava**. Tento typ posunu se nazývá **aritmetický posun**.

---

## Princip dělení

> [!abstract] Postup
> 1.  Binární řetězec čísla **X** se posune o **k-míst doprava**.
> 2.  Na uvolněná místa zleva se nedoplňují nuly, ale **stejná hodnota, jakou měl původní nejvyšší (znaménkový) bit $x_{n-1}$**. Tím je zajištěno zachování znaménka i u záporných čísel.

Výsledkem operace jsou dvě části:
-   **D (podíl):** Celočíselný podíl $D = X \text{ div } 2^k$. Tvoří ho bity, které zůstaly po posunu.
-   **M (zbytek):** Zbytek po dělení $M = X \text{ mod } 2^k$. Tvoří ho bity, které byly posunem "vysunuty" doprava.

---

## Příklad (pro k=2)

> [!example] Dělení číslem 4 ($2^2$)
> Chceme vydělit číslo **X** číslem 4, tedy posouváme o **k=2** místa doprava.
>
> **Původní číslo X:**
> `xₙ₋₁  xₙ₋₂  ...  x₂  x₁  x₀`
>
> **Po posunutí o 2 místa doprava:**
>
> | Původní bity | `xₙ₋₁` | `xₙ₋₂` | `...` | `x₂` | `x₁` | `x₀` |
> | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
> | **Výsledný podíl D** | `xₙ₋₁` | `xₙ₋₁` | `...` | `xₙ₋₂` | `...` | `d₀` |
> | **Výsledný zbytek M**| | | | | `m₁` | `m₀` |
>
> Zleva se doplnila hodnota původního znaménkového bitu $x_{n-1}$. Bity, které zůstaly, tvoří podíl **D**. Bity $x_1$ a $x_0$, které byly vysunuty, tvoří zbytek **M**.

> [!warning] Důležité pro záporná čísla
> V doplňkovém kódu tento postup správně stanoví výsledek **celočíselného dělení (div)** a **zbytku po dělení (mod)**, což se pro záporná čísla může lišit od standardního matematického dělení.



# Čísla v pohyblivé řádové čárce (IEEE 754) 🚤

Pro reprezentaci **reálných čísel** se v počítačích nejčastěji používá standardizovaný **formát IEEE 754**. Základní (32bitová, tzv. single-precision) varianta definuje, jak je reálné číslo `x` uloženo do 32bitového kódového slova `x'`.

> [!abstract] Obecný tvar čísla
> Každé reálné číslo je převedeno do semilogaritmického tvaru:
> $$
> x = \pm 1,m \cdot 2^e
> $$
> Kde:
> - **±** je znaménko.
> - **1,m** je mantisa (normalizovaná tak, aby byla vždy v intervalu `[1, 2)`).
> - **e** je exponent.

---

## Struktura 32bitového kódového slova

32bitové slovo je rozděleno do tří logických částí, z nichž každá kóduje jednu složku výše uvedeného tvaru.

### 1. Znaménko (±)
> [!note]
> - **Bit:** 31 (jeden nejvyšší bit).
> - **Význam:**
>    - **0** = nezáporné číslo (+).
>    - **1** = záporné číslo (-).

### 2. Exponent (e)
> [!info]
> - **Bity:** 30 až 23 (celkem 8 bitů).
> - **Rozsah:** Umožňuje reprezentovat exponent `e` z intervalu `(-126; 127)`.
> - **Kódování:** Do paměti se neukládá přímo exponent `e`, ale jeho posunutá hodnota `e'` (tzv. kód s posunutou nulou neboli *bias*). Pro 8 bitů je posun 127.
> - **Výpočet:**
>   $$
>   e' = e + 127
>   $$

### 3. Mantisa (m)
> [!success]
> - **Bity:** 22 až 0 (celkem 23 bitů).
> - **Význam:** Reprezentuje desetinnou (zlomkovou) část čísla.
> - **Princip:** Protože je číslo vždy normalizováno do tvaru `1,m...`, je úvodní jednička **implicitní** (tzv. *hidden bit*) a do paměti se neukládá. Ukládá se pouze část za desetinnou čárkou, označená jako `m'`.
> - **Výpočet hodnoty:** Hodnota mantisy `m` se z uložených bitů `m' = a₂₂...a₀` vypočítá jako:
>   $$
>   m = \sum_{i=1}^{23} a_{23-i} \cdot 2^{-i}
>   $$

---

### Rozložení bitů

| Bit        | 31                   | 30                       | ... | 23  | 22                       | ... | 0   |
| :--------- | :------------------- | :----------------------- | :-- | :-- | :----------------------- | :-- | :-- |
| **Význam** | **Znaménko** (1 bit) | **Exponent e'** (8 bitů) |     |     | **Mantisa m'** (23 bitů) |     |     |