# K√≥dov√°n√≠ dat a odolnost proti chyb√°m

Aby poƒç√≠taƒç mohl zpracov√°vat jak√°koliv data (text, obr√°zky, ƒç√≠sla), mus√≠ b√Ωt nejprve p≈ôevedena do form√°tu, kter√©mu rozum√≠ ‚Äì do **bin√°rn√≠ soustavy**. Tento proces se naz√Ωv√° k√≥dov√°n√≠.

---

## Reprezentace dat v poƒç√≠taƒçi 

> [!abstract] Co je to k√≥d?
> K√≥d je pravidlo (zobrazen√≠), kter√© ka≈æd√©mu objektu z jedn√© mno≈æiny (nap≈ô. p√≠smen≈Øm abecedy) jednoznaƒçnƒõ p≈ôi≈ôad√≠ prvek z druh√© mno≈æiny ‚Äì tzv. **k√≥dov√© slovo** (nap≈ô. ≈ôetƒõzec nul a jedniƒçek).
> 
> `{ objekty } ‚Üí { k√≥dov√° slova }`

V poƒç√≠taƒç√≠ch se pou≈æ√≠vaj√≠ **bin√°rn√≠ k√≥dy**, kde k√≥dov√Ωmi slovy jsou ≈ôetƒõzce slo≈æen√© pouze z bit≈Ø (0 a 1).

### Kolik slov lze vytvo≈ôit?
Pokud maj√≠ v≈°echna k√≥dov√° slova stejnou d√©lku *n* bit≈Ø, m≈Ø≈æeme vytvo≈ôit $2^n$ r≈Øzn√Ωch unik√°tn√≠ch k√≥dov√Ωch slov.

> [!example] P≈ô√≠klad
> Pro **n = 8 bit≈Ø** (1 bajt) m≈Ø≈æeme vytvo≈ôit $2^8 = 256$ r≈Øzn√Ωch k√≥dov√Ωch slov. To staƒç√≠ nap≈ô√≠klad pro reprezentaci v≈°ech znak≈Ø v tabulce ASCII.

| D√©lka k√≥dov√©ho slova | Poƒçet bit≈Ø (n) | Poƒçet r≈Øzn√Ωch k√≥dov√Ωch slov |
| :------------------- | :------------- | :-------------------------- |
| 1 bit                | 1              | $2^1 = 2$                   |
| 1 p≈Ølbyte (nibble)   | 4              | $2^4 = 16$                  |
| 1 byte               | 8              | $2^8 = 256$                 |
| 2 byty               | 16             | $2^{16} = 65 536$           |
| 4 byty               | 32             | $2^{32} = 4 294 967 296$    |
|                      | $n$            | $2^n$                       |

---

## Hammingova vzd√°lenost 

Bin√°rn√≠ k√≥dov√° slova si m≈Ø≈æeme p≈ôedstavit jako vrcholy v *n*-rozmƒõrn√©m prostoru (hyperkrychli). Hammingova vzd√°lenost n√°m ≈ô√≠k√°, jak "daleko" jsou od sebe dva takov√© vrcholy.

> [!abstract] Definice Hammingovy vzd√°lenosti
> Pro dvƒõ k√≥dov√° slova $X$ a $Y$ stejn√© d√©lky *n* je Hammingova vzd√°lenost $d(X, Y)$ definov√°na jako **poƒçet pozic, na kter√Ωch se jejich bity li≈°√≠**.
> $$
> d(X, Y) = \sum_{i=1}^{n} |x_i - y_i|
> $$

-   **Geometricky:** Je to nejkrat≈°√≠ poƒçet hran, po kter√Ωch mus√≠me proj√≠t, abychom se dostali z vrcholu X do vrcholu Y.

> [!example] P≈ô√≠klad
> Mƒõjme slova $X = (011)$ a $Y = (110)$.
> - Li≈°√≠ se na prvn√≠ pozici (`0` vs `1`) a na t≈ôet√≠ pozici (`1` vs `0`).
> - Jejich Hammingova vzd√°lenost je tedy **d = 2**.

### Minim√°ln√≠ k√≥dov√° vzd√°lenost ($d_{min}$)
Toto je nejd≈Øle≈æitƒõj≈°√≠ parametr cel√©ho k√≥du. Je to **nejmen≈°√≠ Hammingova vzd√°lenost** nalezen√° mezi v≈°emi mo≈æn√Ωmi p√°ry r≈Øzn√Ωch k√≥dov√Ωch slov v dan√©m k√≥du.

$$
d_{min} = \min_{\substack{X_i, X_j \in K \\ i \neq j}} d(X_i, X_j)
$$

> [!important]
> Hodnota $d_{min}$ p≈ô√≠mo urƒçuje schopnost k√≥du **detekovat** a **opravovat** chyby, kter√© vznikaj√≠ nap≈ô√≠klad p≈ôi p≈ôenosu dat.

---

## Rozdƒõlen√≠ k√≥d≈Ø podle odolnosti proti chyb√°m 

Podle hodnoty $d_{min}$ m≈Ø≈æeme k√≥dy rozdƒõlit do t≈ô√≠ kategori√≠:

### 1. Z√°kladn√≠ k√≥d
> [!note] Podm√≠nka: $d_{min} \ge 1$
> Zaji≈°≈•uje pouze to, ≈æe ka≈æd√© k√≥dov√© slovo je unik√°tn√≠. **Nem√° ≈æ√°dnou schopnost detekce ani opravy chyb.**

### 2. Zabezpeƒçuj√≠c√≠ k√≥d (detekce chyb)
> [!warning] Podm√≠nka: $d_{min} \ge 2$
> K√≥d dok√°≈æe spolehlivƒõ **detekovat** (odhalit) a≈æ $t$ chyb, kde plat√≠:
> $$
> t = d_{min} - 1
> $$
> **Princip:** Pokud p≈ôi p≈ôenosu vznikne m√©nƒõ ne≈æ $d_{min}$ chyb, p≈ôijat√© slovo nebude odpov√≠dat ≈æ√°dn√©mu platn√©mu k√≥dov√©mu slovu. V√≠me, ≈æe nastala chyba, ale nev√≠me jak√°.

### 3. Samoopravn√Ω k√≥d (oprava chyb)
> [!success] Podm√≠nka: $d_{min} \ge 3$
> K√≥d dok√°≈æe spolehlivƒõ **opravit** a≈æ $t$ chyb, kde plat√≠:
> $$
> t = \left\lfloor \frac{d_{min} - 1}{2} \right\rfloor
> $$
> **Princip:** I po≈°kozen√© slovo je st√°le "bl√≠≈æe" sv√©mu origin√°lu ne≈æ jak√©mukoli jin√©mu platn√©mu slovu. Dekod√©r tak m≈Ø≈æe jednoznaƒçnƒõ urƒçit p≈Øvodn√≠ slovo a chybu opravit.

### Souhrnn√° tabulka

| Typ k√≥du      | Minim√°ln√≠ vzd√°lenost ($d_{min}$) | Maxim√°ln√≠ poƒçet **detekovateln√Ωch** chyb | Maxim√°ln√≠ poƒçet **opraviteln√Ωch** chyb |
| :------------ | :-----------------------------: | :-------------------------------------: | :-----------------------------------: |
| **Z√°kladn√≠** | $\ge 1$                         | 0                                       | 0                                     |
| **Zabezpeƒçuj√≠c√≠** | $\ge 2$                         | $d_{min} - 1$                           | 0                                     |
| **Samoopravn√Ω** | $\ge 3$                         | $d_{min} - 1$                           | $\lfloor (d_{min}-1)/2 \rfloor$      |

# Konstrukce zabezpeƒçuj√≠c√≠ho k√≥du pomoc√≠ paritn√≠ho bitu

Z√°kladn√≠ k√≥dy, kter√© maj√≠ minim√°ln√≠ vzd√°lenost **$d_{min} = 1$**, nedok√°≈æ√≠ detekovat ≈æ√°dn√© chyby. Jejich schopnosti m≈Ø≈æeme jednodu≈°e vylep≈°it roz≈°√≠≈ôen√≠m o takzvan√Ω **paritn√≠ bit**. T√≠mto mechanismem zv√Ω≈°√≠me minim√°ln√≠ vzd√°lenost k√≥du na $d_{min} = 2$, ƒç√≠m≈æ z√≠sk√°me **zabezpeƒçuj√≠c√≠ k√≥d** schopn√Ω detekovat jednu chybu.

---

## Princip paritn√≠ho bitu

> [!abstract] Definice
> P≈Øvodn√≠ k√≥dov√© slovo $X = (x_1, x_2, \dots, x_n)$ roz≈°√≠≈ô√≠me o jeden p≈ôidan√Ω bit, **paritn√≠ bit $p$**. T√≠m vytvo≈ô√≠me nov√©, del≈°√≠ k√≥dov√© slovo:
> $$
> X' = (x_1, x_2, \dots, x_n, p)
> $$
> Hodnota bitu $p$ se vypoƒç√≠t√° tak, aby celkov√Ω poƒçet jedniƒçek v nov√©m slovƒõ $X'$ spl≈àoval p≈ôedem dan√© pravidlo (paritu).

Existuj√≠ dva z√°kladn√≠ typy parity:

### 1. Lich√° parita (Odd Parity)
> [!note] C√≠l: Celkov√Ω poƒçet jedniƒçek v nov√©m slovƒõ $X'$ mus√≠ b√Ωt **lich√Ω**.
> Paritn√≠ bit $p$ se vypoƒç√≠t√° pomoc√≠ operace XOR (exkluzivn√≠ souƒçet) v≈°ech bit≈Ø p≈Øvodn√≠ho slova a konstanty 1:
> $$
> p = x_1 \oplus x_2 \oplus \dots \oplus x_n \oplus 1
> $$

### 2. Sud√° parita (Even Parity)
> [!note] C√≠l: Celkov√Ω poƒçet jedniƒçek v nov√©m slovƒõ $X'$ mus√≠ b√Ωt **sud√Ω**.
> Paritn√≠ bit $p$ se vypoƒç√≠t√° jako XOR v≈°ech bit≈Ø p≈Øvodn√≠ho slova:
> $$
> p = x_1 \oplus x_2 \oplus \dots \oplus x_n
> $$

---

### P≈ô√≠klad v praxi

Mƒõjme p≈Øvodn√≠ k√≥dov√© slovo **X = (1011)**. Poƒçet jedniƒçek je 3 (lich√Ω).

-   **Pro lichou paritu:**
    - Chceme, aby celkov√Ω poƒçet jedniƒçek z≈Østal lich√Ω (3, 5, ...).
    - Mus√≠me tedy p≈ôidat $p=0$.
    - Nov√© k√≥dov√© slovo je **$X' = (10110)$**. Poƒçet jedniƒçek je 3.

-   **Pro sudou paritu:**
    - Chceme, aby celkov√Ω poƒçet jedniƒçek byl sud√Ω (2, 4, ...).
    - Mus√≠me tedy p≈ôidat $p=1$.
    - Nov√© k√≥dov√© slovo je **$X' = (10111)$**. Poƒçet jedniƒçek je 4.

> [!success] V√Ωsledek
> Pokud se p≈ôi p≈ôenosu slova $X'=(10111)$ zmƒõn√≠ jeden bit (nap≈ô. na $10**0**11$), p≈ôij√≠maƒç okam≈æitƒõ zjist√≠, ≈æe parita nesed√≠ (poƒçet jedniƒçek je 3, co≈æ nen√≠ sud√©), a t√≠m **detekuje chybu**.


# Konstrukce samoopravn√©ho k√≥du (Hammingovy k√≥dy)

C√≠lem je vytvo≈ôit k√≥d, kter√Ω dok√°≈æe nejen detekovat, ale i **opravit jednu chybu**. Toho dos√°hneme, pokud bude minim√°ln√≠ vzd√°lenost mezi v≈°emi platn√Ωmi k√≥dov√Ωmi slovy **$d_{min} = 3$**.

---

## Postup konstrukce

1.  **Vych√°z√≠me z dat:** M√°me zpr√°vu, kter√° se skl√°d√° z **`m` datov√Ωch bit≈Ø** ($d_1, d_2, \dots, d_m$). Samotn√° tato zpr√°va m√° $d_{min} = 1$.

2.  **P≈ôid√°me kontroln√≠ bity:** K√≥d roz≈°√≠≈ô√≠me o **`k` paritn√≠ch (kontroln√≠ch) bit≈Ø** ($p_1, p_2, \dots, p_k$).

3.  **Vznikne nov√© k√≥dov√© slovo:** V√Ωsledn√© slovo m√° celkovou d√©lku **`m + k`** bit≈Ø a je slo≈æeno z p≈Øvodn√≠ch datov√Ωch a novƒõ p≈ôidan√Ωch paritn√≠ch bit≈Ø.

---

## Kl√≠ƒçov√° podm√≠nka (Hammingova nerovnost)

Aby k√≥d mohl opravit jednu chybu, mus√≠ poƒçet paritn√≠ch bit≈Ø `k` staƒçit k zak√≥dov√°n√≠ informace o tom, **na kter√© pozici** v cel√©m slovƒõ chyba nastala, plus jeden stav pro p≈ô√≠pad, ≈æe **≈æ√°dn√° chyba nenastala**.

> [!important] Podm√≠nka pro samoopravn√Ω k√≥d
> Poƒçet datov√Ωch bit≈Ø `m` a paritn√≠ch bit≈Ø `k` mus√≠ spl≈àovat n√°sleduj√≠c√≠ nerovnost:
> $$
> m + k + 1 \le 2^k
> $$

### Vysvƒõtlen√≠ nerovnosti:
-   **$m + k$**: Poƒçet pozic v k√≥dov√©m slovƒõ, na kter√Ωch m≈Ø≈æe nastat chyba.
-   **$+ 1$**: P≈ôedstavuje stav, kdy k ≈æ√°dn√© chybƒõ nedo≈°lo.
-   **$m + k + 1$**: Celkov√Ω poƒçet stav≈Ø, kter√© pot≈ôebujeme rozli≈°it (chyba na 1. bitu, chyba na 2. bitu, ..., ≈æ√°dn√° chyba).
-   **$2^k$**: Celkov√Ω poƒçet informac√≠ (stav≈Ø), kter√© m≈Ø≈æeme zak√≥dovat pomoc√≠ `k` paritn√≠ch bit≈Ø.

Paritn√≠ bity mus√≠ m√≠t dostateƒçnou "kapacitu" ($2^k$), aby dok√°zaly pokr√Ωt v≈°echny mo≈æn√© p≈ô√≠pady chyb a bezchybn√Ω stav ($m+k+1$).

> [!example] P≈ô√≠klad
> Chceme p≈ôen√©st **m = 4** datov√© bity (nap≈ô. `1011`). Kolik paritn√≠ch bit≈Ø `k` pot≈ôebujeme k vytvo≈ôen√≠ samoopravn√©ho k√≥du?
>
> -   Zkus√≠me **k = 2**:
>     $4 + 2 + 1 \le 2^2 \implies 7 \le 4$  ... **Nevyhovuje.**
> -   Zkus√≠me **k = 3**:
>     $4 + 3 + 1 \le 2^3 \implies 8 \le 8$  ... **Vyhovuje!**
>
> Pro 4 datov√© bity tedy pot≈ôebujeme 3 paritn√≠ bity. Vytvo≈ô√≠me tak k√≥dov√© slovo o celkov√© d√©lce 7 bit≈Ø (zn√°m√Ω jako Hamming≈Øv k√≥d H(7,4)).


# Hamming≈Øv k√≥d ‚Äì Konstrukce a princip

Hamming≈Øv k√≥d je typ **samoopravn√©ho k√≥du**, kter√Ω dok√°≈æe detekovat a≈æ dvƒõ chyby a **opravit jednu chybu**. Proto se oznaƒçuje jako **SEC** (Single Error Correcting). Jeho kl√≠ƒçovou vlastnost√≠ je minim√°ln√≠ vzd√°lenost **$d_{min} = 3$**.

---

## 1. Uspo≈ô√°d√°n√≠ datov√Ωch a paritn√≠ch bit≈Ø

Nejprve je nutn√© spr√°vnƒõ uspo≈ô√°dat datov√© bity ($d_1 \dots d_m$) a paritn√≠ bity ($p_1 \dots p_k$) do v√Ωsledn√©ho k√≥dov√©ho slova.

> [!abstract] Pravidla pro uspo≈ô√°d√°n√≠
> 1.  **Paritn√≠ bity ($p$)** se umis≈•uj√≠ na pozice, jejich≈æ ƒç√≠slo je **mocninou dvou** (1, 2, 4, 8, 16, ‚Ä¶).
> 2.  **Datov√© bity ($d$)** se postupnƒõ vlo≈æ√≠ na **v≈°echny zb√Ωvaj√≠c√≠ voln√© pozice**.

V√Ωsledn√© uspo≈ô√°d√°n√≠ k√≥dov√©ho slova tedy vypad√° takto:
`p‚ÇÅ p‚ÇÇ d‚ÇÅ p‚ÇÑ d‚ÇÇ d‚ÇÉ d‚ÇÑ p‚Çà d‚ÇÖ d‚ÇÜ d‚Çá d‚Çà ...`
nebo podle index≈Ø:
`1(p) 2(p) 3(d) 4(p) 5(d) 6(d) 7(d) 8(p) 9(d) ...`

---

## 2. V√Ωpoƒçet paritn√≠ch bit≈Ø

Ka≈æd√Ω paritn√≠ bit "kontroluje" specifickou skupinu bit≈Ø (vƒçetnƒõ sebe sama) v cel√©m k√≥dov√©m slovƒõ. Kter√© bity kontroluje, je d√°no jeho vlastn√≠ pozic√≠.

> [!info] Princip kontroly
> Pozice paritn√≠ho bitu urƒçuje, kterou sekvenci bit≈Ø bude kontrolovat. Pod√≠v√°me se na bin√°rn√≠ reprezentaci pozic v≈°ech bit≈Ø v k√≥dov√©m slovƒõ. Paritn√≠ bit $p_i$ (na pozici $2^{i-1}$) kontroluje v≈°echny bity, jejich≈æ ƒç√≠slo pozice m√° na *i*-t√© pozici v bin√°rn√≠m z√°pisu jedniƒçku.
>
> **Jednodu≈°≈°√≠ pravidlo:**
> -   **p‚ÇÅ (pozice 1):** Kontroluje v≈°echny bity na pozic√≠ch 1, 3, 5, 7, 9, 11, ‚Ä¶ (p≈ôeskakuje po jednom: vezmi 1, p≈ôeskoƒç 1, vezmi 1...).
> -   **p‚ÇÇ (pozice 2):** Kontroluje v≈°echny bity na pozic√≠ch 2, 3, 6, 7, 10, 11, ‚Ä¶ (p≈ôeskakuje po dvou: vezmi 2, p≈ôeskoƒç 2, vezmi 2...).
> -   **p‚ÇÑ (pozice 4):** Kontroluje v≈°echny bity na pozic√≠ch 4, 5, 6, 7, 12, 13, 14, 15, ‚Ä¶ (p≈ôeskakuje po ƒçty≈ôech: vezmi 4, p≈ôeskoƒç 4, vezmi 4...).
> -   **p‚Çà (pozice 8):** Kontroluje bity 8-15, 24-31, atd.

Hodnota ka≈æd√©ho paritn√≠ho bitu se pak vypoƒç√≠t√° jako **XOR** v≈°ech datov√Ωch bit≈Ø, kter√© kontroluje. C√≠lem je obvykle dos√°hnout **sud√© parity** pro ka≈ædou kontrolovanou skupinu.

> [!example] P≈ô√≠klad pro H(7,4) ‚Äì data `1011`
> 1.  **Uspo≈ô√°d√°n√≠:** M√°me 4 datov√© bity ($d_1=1, d_2=0, d_3=1, d_4=1$) a pot≈ôebujeme 3 paritn√≠ bity ($p_1, p_2, p_4$).
>     `_ _ 1 _ 0 1 1` (pozice 1-7)
>     `p‚ÇÅ p‚ÇÇ d‚ÇÅ p‚ÇÑ d‚ÇÇ d‚ÇÉ d‚ÇÑ`
>
> 2.  **V√Ωpoƒçet paritn√≠ch bit≈Ø (pro sudou paritu):**
>     -   **p‚ÇÅ** kontroluje pozice 3, 5, 7 (d‚ÇÅ, d‚ÇÇ, d‚ÇÑ) -> `1 ‚äï 0 ‚äï 1 = 0`. Tedy **p‚ÇÅ = 0**.
>     -   **p‚ÇÇ** kontroluje pozice 3, 6, 7 (d‚ÇÅ, d‚ÇÉ, d‚ÇÑ) -> `1 ‚äï 1 ‚äï 1 = 1`. Tedy **p‚ÇÇ = 1**.
>     -   **p‚ÇÑ** kontroluje pozice 5, 6, 7 (d‚ÇÇ, d‚ÇÉ, d‚ÇÑ) -> `0 ‚äï 1 ‚äï 1 = 0`. Tedy **p‚ÇÑ = 0**.
>
> 3.  **V√Ωsledn√© k√≥dov√© slovo:** `0110011`

Tento postup zajist√≠, ≈æe pokud dojde k jedn√© chybƒõ, poru≈°√≠ se pr√°vƒõ ta kombinace paritn√≠ch bit≈Ø, jej√≠≈æ souƒçet pozic uk√°≈æe p≈ôesnƒõ na m√≠sto chyby.



# Konstrukce Hammingova k√≥du: P≈ô√≠klad (8,4)

Tento p≈ô√≠klad ukazuje, jak vytvo≈ôit samoopravn√Ω Hamming≈Øv k√≥d pro zpr√°vu, kter√° m√° **m = 8 datov√Ωch bit≈Ø**.

---

## 1. Urƒçen√≠ poƒçtu paritn√≠ch bit≈Ø (k)

Nejprve mus√≠me zjistit, kolik paritn√≠ch (kontroln√≠ch) bit≈Ø pot≈ôebujeme k zabezpeƒçen√≠ 8 datov√Ωch bit≈Ø. K tomu pou≈æijeme Hammingovu nerovnost.

> [!important] Hammingova nerovnost
> Poƒçet paritn√≠ch bit≈Ø `k` mus√≠ b√Ωt dostateƒçnƒõ velk√Ω, aby dok√°zal pokr√Ωt v≈°echny mo≈æn√© stavy (chyba na kter√©koli z `m+k` pozic + stav bez chyby).
> $$
> m + k + 1 \le 2^k
> $$

Pro **m = 8**:
-   Zkus√≠me **k = 3**:
    $8 + 3 + 1 \le 2^3 \implies 12 \le 8$ ... **‚ùå Nevyhovuje.**
-   Zkus√≠me **k = 4**:
    $8 + 4 + 1 \le 2^4 \implies 13 \le 16$ ... **‚úÖ Vyhovuje!**

Pot≈ôebujeme tedy **4 paritn√≠ bity**. V√Ωsledn√© k√≥dov√© slovo bude m√≠t celkovou d√©lku $m+k = 8+4 = 12$ bit≈Ø.

---

## 2. V√Ωpoƒçet hodnot paritn√≠ch bit≈Ø

Ka≈æd√Ω paritn√≠ bit je vypoƒç√≠t√°n jako **XOR (‚äï)** z peƒçlivƒõ vybran√© skupiny datov√Ωch bit≈Ø. Kter√© datov√© bity se pou≈æij√≠ pro v√Ωpoƒçet, z√°vis√≠ na pozici paritn√≠ho bitu.

> [!info] Princip kontroly
> Paritn√≠ bit na pozici $2^n$ (tedy $p_1, p_2, p_4, p_8$) kontroluje v≈°echny datov√© bity na pozic√≠ch, jejich≈æ ƒç√≠slo pozice m√° v bin√°rn√≠m z√°pisu na $(n+1)$-t√©m m√≠stƒõ jedniƒçku.

Pro p≈ôehlednost pou≈æijeme standardn√≠ znaƒçen√≠ paritn√≠ch bit≈Ø podle jejich pozice ($p_1, p_2, p_4, p_8$).

#### **Paritn√≠ bit $p_1$ (pozice 1)**
-   Kontroluje v≈°echny bity na lich√Ωch pozic√≠ch (3, 5, 7, 9, 11).
-   To odpov√≠d√° datov√Ωm bit≈Øm **$d_1, d_2, d_4, d_5, d_7$**.
-   $$ p_1 = d_1 \oplus d_2 \oplus d_4 \oplus d_5 \oplus d_7 $$

#### **Paritn√≠ bit $p_2$ (pozice 2)**
-   Kontroluje bity na pozic√≠ch 3, 6, 7, 10, 11.
-   To odpov√≠d√° datov√Ωm bit≈Øm **$d_1, d_3, d_4, d_6, d_7$**.
-   $$ p_2 = d_1 \oplus d_3 \oplus d_4 \oplus d_6 \oplus d_7 $$

#### **Paritn√≠ bit $p_4$ (pozice 4)**
-   *Na slidu oznaƒçen jako $p_3$.*
-   Kontroluje bity na pozic√≠ch 5, 6, 7, 12.
-   To odpov√≠d√° datov√Ωm bit≈Øm **$d_2, d_3, d_4, d_8$**.
-   $$ p_4 = d_2 \oplus d_3 \oplus d_4 \oplus d_8 $$

#### **Paritn√≠ bit $p_8$ (pozice 8)**
-   *Na slidu oznaƒçen jako $p_4$.*
-   Kontroluje bity na pozic√≠ch 9, 10, 11, 12.
-   To odpov√≠d√° datov√Ωm bit≈Øm **$d_5, d_6, d_7, d_8$**.
-   $$ p_8 = d_5 \oplus d_6 \oplus d_7 \oplus d_8 $$

Tento syst√©m v√Ωpoƒçtu zaji≈°≈•uje, ≈æe pokud dojde k jednobitov√© chybƒõ, kombinace chybn√Ωch paritn√≠ch kontrol jednoznaƒçnƒõ identifikuje pozici t√©to chyby.


# Princip zabezpeƒçen√≠ dat SEC k√≥dem 

**SEC (Single Error Correcting)** k√≥dy, jako je Hamming≈Øv k√≥d, jsou navr≈æeny tak, aby dok√°zaly automaticky **opravit chybu v jednom bitu**. N√°sleduj√≠c√≠ diagram a popis vysvƒõtluj√≠, jak tento proces funguje v praxi, nap≈ô√≠klad p≈ôi ukl√°d√°n√≠ dat do pamƒõti.

---

## Proces k√≥dov√°n√≠ a opravy chyby

![[Pasted image 20251013132437.png]]


Cel√Ω mechanismus lze rozdƒõlit do dvou f√°z√≠: z√°pis (k√≥dov√°n√≠) a ƒçten√≠ (kontrola a oprava).

#### 1. F√°ze: Z√°pis dat do pamƒõti
-   Pro p≈Øvodn√≠ **datov√© bity ($d_1...d_8$)** se v **gener√°toru parity** vypoƒç√≠taj√≠ p≈ô√≠slu≈°n√© **paritn√≠ bity ($p_1...p_4$)**.
-   Do hlavn√≠ pamƒõti se ulo≈æ√≠ kompletn√≠ k√≥dov√© slovo, kter√© obsahuje jak p≈Øvodn√≠ data, tak vypoƒç√≠tan√© paritn√≠ bity.

#### 2. F√°ze: ƒåten√≠ dat z pamƒõti
-   Z pamƒõti se naƒçtou datov√© bity ($d'_1...d'_8$) a paritn√≠ bity ($p'_1...p'_4$). Bƒõhem ulo≈æen√≠ mohlo doj√≠t k chybƒõ, proto je znaƒç√≠me ƒç√°rkou.
-   Ze naƒçten√Ωch datov√Ωch bit≈Ø ($d'$) se v druh√©m gener√°toru parity **znovu vypoƒç√≠t√°** sada kontroln√≠ch paritn√≠ch bit≈Ø.
-   **Kompar√°tor** porovn√° p≈Øvodn√≠ (naƒçten√©) paritn√≠ bity s tƒõmi novƒõ vypoƒç√≠tan√Ωmi.
-   V√Ωsledek porovn√°n√≠ je tzv. **syndrom**:
    -   **Nulov√Ω syndrom:** V≈°echny paritn√≠ kontroly sed√≠. Data jsou v po≈ô√°dku.
    -   **Nenulov√Ω syndrom:** Kontroly nesed√≠. Hodnota syndromu p≈ôesnƒõ odpov√≠d√° **pozici chybn√©ho bitu**.
-   **Korektor** na z√°kladƒõ nenulov√©ho syndromu provede opravu ‚Äì jednodu≈°e **otoƒç√≠ (zneguju) bit na chybn√© pozici**.

---

## Omezen√≠ a vylep≈°en√≠ SEC k√≥du

### Co se stane p≈ôi v√≠ce chyb√°ch?
> [!warning] Probl√©m dvou chyb
> Standardn√≠ SEC k√≥d si sice skvƒõle porad√≠ s jednou chybou, ale pokud nastanou **chyby ve dvou bitech**, korektor je **oprav√≠ ≈°patnƒõ**. Syndrom bude ukazovat na t≈ôet√≠, zcela nevinn√Ω bit, kter√Ω korektor otoƒç√≠. V√Ωsledkem budou data se t≈ôemi chybami m√≠sto p≈Øvodn√≠ch dvou.

### ≈òe≈°en√≠: SEC DED k√≥d 
Aby se p≈ôede≈°lo chybn√© opravƒõ, roz≈°i≈ôuje se SEC k√≥d na **SEC DED (Single Error Correcting, Double Error Detecting)** k√≥d.

> [!success] Princip SEC DED
> K cel√©mu k√≥dov√©mu slovu (data + paritn√≠ bity) se p≈ôid√° **jeden dal≈°√≠ bit celkov√© parity** (nap≈ô. sud√©). Tento bit kontroluje paritu cel√©ho slova.
> 
> D√≠ky tomu dok√°≈æe syst√©m rozli≈°it mezi jednou a dvƒõma chybami:
> 1.  **Jedna chyba:** Nesed√≠ syndrom z Hammingova k√≥du **A Z√ÅROVE≈á** nesed√≠ celkov√° parita. **‚Üí Syst√©m chybu oprav√≠.**
> 2.  **Dvƒõ chyby:** Nesed√≠ syndrom z Hammingova k√≥du, ale celkov√° parita **SED√ç** (dvƒõ zmƒõny se navz√°jem vyru≈°√≠). **‚Üí Syst√©m detekuje neopravitelnou chybu a opravu neprovede.** M√≠sto toho nahl√°s√≠ probl√©m.

# Data v poƒç√≠taƒçi 

Ve≈°ker√° data, se kter√Ωmi poƒç√≠taƒç pracuje, m≈Ø≈æeme rozdƒõlit do dvou z√°kladn√≠ch kategori√≠ podle jejich √∫ƒçelu: na data, kter√° nesou informaci, a data, kter√° ≈ô√≠kaj√≠, co se s informacemi m√° dƒõlat.

---

## 1. Informaƒçn√≠ data (Element√°rn√≠ datov√© typy)

> [!note]
> Jsou to data, kter√° po spr√°vn√© interpretaci **p≈ôin√°≈°ej√≠ nƒõjakou informaci**. Jedn√° se o z√°kladn√≠ stavebn√≠ kameny, se kter√Ωmi programy pracuj√≠.

Mezi z√°kladn√≠ informaƒçn√≠ data pat≈ô√≠:

-    **Logick√© hodnoty:** Reprezentuj√≠ pravdu nebo nepravdu (nap≈ô. `true`/`false`, `1`/`0`).
-    **Znaky:** Jednotliv√© symboly, jako jsou p√≠smena, ƒç√≠slice nebo speci√°ln√≠ znaky (nap≈ô. 'A', '!', '5').
-    **ƒå√≠sla:**
    -   **V pevn√© ≈ô√°dov√© ƒç√°rce:** Pou≈æ√≠vaj√≠ se pro reprezentaci **cel√Ωch ƒç√≠sel** (nap≈ô. 10, -150, 0).
    -   **V pohybliv√© (plovouc√≠) ≈ô√°dov√© ƒç√°rce:** Pou≈æ√≠vaj√≠ se pro reprezentaci **re√°ln√Ωch ƒç√≠sel** (nap≈ô. 3.14, -0.0025).

---

## 2. Povelov√° data (Instrukce programu)

> [!important]
> Jsou to data, kter√° **urƒçuj√≠ poƒç√≠taƒçi (procesoru), jak√Ωm zp≈Øsobem m√° zpracov√°vat informaƒçn√≠ data**. Jde v podstatƒõ o samotn√Ω program ‚Äì s√©rii p≈ô√≠kaz≈Ø, kter√© procesor vykon√°v√°.

Nap≈ô√≠klad povelov√© dato m≈Ø≈æe b√Ωt instrukce "seƒçti dvƒõ ƒç√≠sla" nebo "ulo≈æ tento znak do pamƒõti".


# K√≥dov√°n√≠ logick√Ωch hodnot 

Logick√° hodnota p≈ôedstavuje v√Ωsledek rozhodnut√≠, zda je nƒõco **pravda**, nebo **nepravda**. Jde o nejz√°kladnƒõj≈°√≠ typ dat v informatice.

---

## Ulo≈æen√≠ v pamƒõti 

I kdy≈æ logick√° hodnota nese pouze 1 bit informace, v praxi se pro jej√≠ ulo≈æen√≠ pou≈æ√≠v√° v√≠ce m√≠sta.

-   **Teoreticky:** K ulo≈æen√≠ by staƒçilo k√≥dov√© slovo d√©lky **1 bit**.
-   **V praxi:** Logick√° hodnota se obvykle ukl√°d√° do k√≥dov√©ho slova o velikosti **1 bajtu (8 bit≈Ø)**. D≈Øvodem je, ≈æe modern√≠ procesory jsou optimalizov√°ny pro pr√°ci s cel√Ωmi bajty, a p≈ô√≠stup k jednotliv√Ωm bit≈Øm by byl pomalej≈°√≠ a slo≈æitƒõj≈°√≠.

---

## Reprezentace hodnot

Samotn√© hodnoty `pravda` a `nepravda` jsou v pamƒõti reprezentov√°ny specifick√Ωmi ƒç√≠seln√Ωmi hodnotami.

### ‚ùå Nepravda (False)
-   Je reprezentov√°na jako **logick√° 0**.
-   V≈ædy odpov√≠d√° k√≥dov√©mu slovu s **nulovou hodnotou**.
-   **K√≥dov√© slovo:** `0000 0000`

### ‚úÖ Pravda (True)
-   Je reprezentov√°na jako **logick√° 1**.
-   M≈Ø≈æe b√Ωt reprezentov√°na **jakoukoliv nenulovou hodnotou**.
-   **P≈ô√≠klad k√≥dov√©ho slova:** `0000 0001`, `1111 1111`, `0101 0101` atd.

> [!important] Kl√≠ƒçov√Ω princip
> P≈ôi vyhodnocov√°n√≠ logick√© hodnoty se poƒç√≠taƒç nept√° "je to rovno 1?", ale pt√° se "je to r≈Øzn√© od 0?". To zjednodu≈°uje mnoho operac√≠.


# Reprezentace textu/znak≈Ø 

Ka≈æd√Ω **text** ch√°peme jako posloupnost jednotliv√Ωch znak≈Ø z nƒõjak√© abecedy (nap≈ô√≠klad latinky, azbuky atd.). Ka≈æd√Ω znak m√° svoji specifickou znakovou hodnotu, kterou poƒç√≠taƒç ukl√°d√°.

---

## Dvƒõ slo≈æky ulo≈æen√©ho textu

P≈ôi ukl√°d√°n√≠ textu v modern√≠ch programech se ve skuteƒçnosti ukl√°daj√≠ dvƒõ oddƒõlen√© skupiny informac√≠:

### 1. Informace o znac√≠ch (Prost√Ω text)
> [!note]
> Toto je samotn√Ω obsah ‚Äì sekvence znak≈Ø, kter√© tvo≈ô√≠ text. Nap≈ô√≠klad "Ahoj svƒõte!".

### 2. Informace o form√°tov√°n√≠ textu
> [!info]
> Toto jsou vizu√°ln√≠ instrukce, kter√© urƒçuj√≠, jak m√° text vypadat. Pat≈ô√≠ sem nap≈ô√≠klad:
> - Velikost a typ p√≠sma (font)
> - Barva textu
> - Podtr≈æen√≠, kurz√≠va, tuƒçn√© p√≠smo
> - Zarovn√°n√≠, ≈ô√°dkov√°n√≠ atd.

---

> [!important] Zamƒõ≈ôen√≠ na prost√Ω text
> Zp≈Øsob, jak√Ωm r≈Øzn√© programy (Word, Google Docs, Pages) ukl√°daj√≠ form√°tov√°n√≠, se v√Ωraznƒõ li≈°√≠ a je ƒçasto velmi komplexn√≠. Z hlediska z√°kladn√≠ch princip≈Ø poƒç√≠taƒç≈Ø se proto budeme zab√Ωvat p≈ôedev≈°√≠m t√≠m, jak se ukl√°d√° **prost√Ω text**, tedy samotn√© znaky.


# Znaky: ≈ò√≠d√≠c√≠ a Grafick√©

Znaky, resp. jejich k√≥dov√© hodnoty, m≈Ø≈æeme rozdƒõlit do dvou z√°kladn√≠ch skupin podle jejich funkce a v√Ωznamu.

---

## 1. ≈ò√≠d√≠c√≠ znaky (Control Characters) 

> [!note]
> **≈ò√≠d√≠c√≠ znak** je speci√°ln√≠ znak, jeho≈æ √∫ƒçelem nen√≠ zobrazen√≠, ale **≈ô√≠zen√≠ zpracov√°n√≠** ostatn√≠ch znakov√Ωch hodnot.

-   Tyto znaky nemaj√≠ ≈æ√°dnou viditelnou podobu, proto se oznaƒçuj√≠ jako tzv. **netisknuteln√© znaky**.
-   Slou≈æ√≠ k form√°tov√°n√≠ textu, ≈ô√≠zen√≠ komunikace nebo ovl√°d√°n√≠ za≈ô√≠zen√≠ (jako je tisk√°rna nebo termin√°l).
-   **P≈ô√≠klady:**
    -   **Nov√° ≈ô√°dka** (p≈ô√≠kaz pro p≈ôesun na dal≈°√≠ ≈ô√°dek, typicky generov√°n kl√°vesou `Enter`).
    -   **Konec zpr√°vy** (oznaƒçuje konec datov√©ho bloku).
    -   **Tabul√°tor**.
    -   **Zvonek** (p≈ô√≠kaz pro p√≠pnut√≠).

---

## 2. Grafick√© znaky (Printable Characters) 

> [!info]
> **Grafick√Ω znak** m√° v√Ωznam viditeln√©ho grafick√©ho symbolu.

-   Tyto znaky p≈ôedstavuj√≠ tzv. **vnƒõj≈°√≠ reprezentaci** dat, kter√° je vhodn√° pro zobrazen√≠ na monitoru nebo pro tisk na tisk√°rnƒõ.
-   Jsou to v≈°echny znaky, kter√© bƒõ≈ænƒõ vid√≠me a p√≠≈°eme.
-   **P≈ô√≠klady:**
    -   **P√≠smena:** `A`, `b`, `ƒç`, `X`
    -   **ƒå√≠slice:** `1`, `5`, `9`
    -   **Interpunkce:** `.`, `,`, `?`, `!`
    -   **Znaƒçky:** `@`, `#`, `‚Ç¨`, `$`

# Reprezentace prost√©ho textu 

Ulo≈æen√≠ prost√©ho textu v poƒç√≠taƒçi prob√≠h√° ve t≈ôech z√°kladn√≠ch kroc√≠ch. C√≠lem je p≈ôev√©st lidsky ƒçiteln√Ω text na s√©rii nul a jedniƒçek, kter√Ωm rozum√≠ procesor.

---

## Princip reprezentace

> [!abstract] Postup ulo≈æen√≠ textu
> 1.  **Rozdƒõlen√≠ na znaky:** Text se nejprve rozlo≈æ√≠ na posloupnost jednotliv√Ωch znak≈Ø.
> 2.  **K√≥dov√°n√≠ (P≈ôevod na ƒç√≠slo):** Ka≈æd√Ω znak se pomoc√≠ speci√°ln√≠ p≈ôevodn√≠ tabulky (znakov√©ho k√≥du, nap≈ô. ASCII nebo Unicode) p≈ôevede na odpov√≠daj√≠c√≠ ƒç√≠selnou hodnotu (k√≥dov√© slovo).
>     -   `Znak ‚Üí ƒå√≠slo`
> 3.  **P≈ôevod do dvojkov√© soustavy:** V√Ωsledn√© ƒç√≠slo se p≈ôevede do bin√°rn√≠ (dvojkov√©) soustavy, co≈æ je fin√°ln√≠ podoba, v jak√© je znak ulo≈æen v pamƒõti poƒç√≠taƒçe.
>     -   `ƒå√≠slo ‚Üí Bin√°rn√≠ ƒç√≠slo`

---

## P≈ô√≠klad: Ulo≈æen√≠ textu "AHOJ"

> [!example] Zpracov√°n√≠ slova "AHOJ"
> **1. krok: Rozdƒõlen√≠ na znaky**
> Text rozdƒõl√≠me na jednotliv√© znaky: `A`, `H`, `O`, `J`.
> 
> **2. krok: K√≥dov√°n√≠ (p≈ôevod na ƒç√≠sla dle ASCII tabulky)**
> Ka≈æd√©mu znaku p≈ôi≈ôad√≠me jeho des√≠tkovou hodnotu:
> -   `A` ‚Üí `65`
> -   `H` ‚Üí `72`
> -   `O` ‚Üí `79`
> -   `J` ‚Üí `74`
> 
> **3. krok: P≈ôevod do dvojkov√© soustavy**
> Ka≈æd√© ƒç√≠slo p≈ôevedeme na 8bitov√© bin√°rn√≠ slovo:
> -   `65` ‚Üí `01000001`
> -   `72` ‚Üí `01001000`
> -   `79` ‚Üí `01001111`
> -   `74` ‚Üí `01001010`
> 
> **V√Ωsledek:** Text "AHOJ" je v pamƒõti poƒç√≠taƒçe ulo≈æen jako sekvence bit≈Ø:
> `01000001 01001000 01001111 01001010`


# K√≥dov√°n√≠ znakov√Ωch hodnot: ASCII a Unicode

Pro p≈ôevod znak≈Ø na ƒç√≠sla (a n√°slednƒõ do bin√°rn√≠ podoby) pou≈æ√≠v√° vƒõt≈°ina program≈Ø jednu ze t≈ô√≠ hlavn√≠ch metod, kter√© se historicky vyv√≠jely.

---

### 1. 7-bitov√Ω ASCII k√≥d (1973)

> [!note] ASCII: American Standard Code for Information Interchange
> Jedn√° se o p≈Øvodn√≠, z√°kladn√≠ standard pro k√≥dov√°n√≠ znak≈Ø.

-   **Velikost slova:** Pro ka≈æd√Ω znak pou≈æ√≠v√° **7-bitov√°** k√≥dov√° slova.
-   **Kapacita:** Umo≈æ≈àuje zak√≥dovat **128 r≈Øzn√Ωch znak≈Ø** ($2^7$).
-   **Obsah:** Zahrnuje anglickou abecedu (bez diakritiky), ƒç√≠slice, interpunkci a z√°kladn√≠ ≈ô√≠d√≠c√≠ znaky. Pro ƒçe≈°tinu a jin√© n√°rodn√≠ jazyky byl nedostateƒçn√Ω.

---

### 2. 8-bitov√Ω ASCII k√≥d (K√≥dov√© str√°nky, 90. l√©ta)

> [!info] Roz≈°√≠≈ôen√≠ pro n√°rodn√≠ jazyky
> S n√°stupem pot≈ôeby reprezentovat znaky s diakritikou (jako `ƒç`, `≈ô`, `≈°`) byl ASCII k√≥d roz≈°√≠≈ôen o jeden bit.

-   **Velikost slova:** Pro ka≈æd√Ω znak pou≈æ√≠v√° **8-bitov√°** k√≥dov√° slova (1 bajt).
-   **Kapacita:** Umo≈æ≈àuje zak√≥dovat **256 r≈Øzn√Ωch znak≈Ø** ($2^8$).
-   **Princip:** Prvn√≠ch 128 znak≈Ø z≈Østalo stejn√Ωch jako v 7-bitov√©m ASCII. Druh√° polovina (znaky 128-255) byla vyu≈æita pro n√°rodn√≠ abecedy. Probl√©mem bylo, ≈æe existovalo mnoho r≈Øzn√Ωch "k√≥dov√Ωch str√°nek" (nap≈ô. jin√° pro ƒçe≈°tinu, jin√° pro azbuku), co≈æ vedlo k probl√©m≈Øm s kompatibilitou.

---

### 3. Unicode (1991)

> [!success] Univerz√°ln√≠ standard
> Unicode vznikl jako snaha vytvo≈ôit jednotn√Ω standard, kter√Ω by dok√°zal reprezentovat v≈°echny znaky v≈°ech svƒõtov√Ωch jazyk≈Ø.

-   **Velikost slova:** Pou≈æ√≠v√° k√≥dov√° slova promƒõnliv√© velikosti, typicky **1 a≈æ 4 bajty** (8 a≈æ 32 bit≈Ø).
-   **Kapacita:** Umo≈æ≈àuje zak√≥dovat obrovsk√© mno≈æstv√≠ znak≈Ø (v dobƒõ vzniku slidu cca 100 000, dnes ji≈æ p≈ôes 140 000).
-   **V√Ωhoda:** Odstra≈àuje probl√©my s nekompatibilitou k√≥dov√Ωch str√°nek a umo≈æ≈àuje v jednom textu kombinovat znaky z r≈Øzn√Ωch jazyk≈Ø (nap≈ô. latinku, ≈ôeƒçtinu a ƒç√≠nsk√© znaky). Dnes je to nejpou≈æ√≠vanƒõj≈°√≠ standard.


# 7-bitov√Ω ASCII k√≥d

> [!note] ASCII: American Standard Code for Information Interchange
> 7-bitov√Ω ASCII je z√°kladn√≠ znakov√° sada, kter√° definuje **128 unik√°tn√≠ch k√≥d≈Ø** (od 0 do 127) pro reprezentaci p√≠smen, ƒç√≠slic, interpunkce a ≈ô√≠d√≠c√≠ch znak≈Ø.

---

## Obsah a struktura tabulky

![[Pasted image 20251013133706.png]]

Tabulka ASCII obsahuje n√°sleduj√≠c√≠ skupiny znak≈Ø:

-    **P√≠smena abecedy:** Velk√° (A-Z) a mal√° (a-z), av≈°ak **bez diakritiky**.
-    **ƒå√≠slice:** `0` a≈æ `9`.
-    **Vƒõtnou interpunkci:** Zahrnuje znaky jako ƒç√°rka, teƒçka, vyk≈ôiƒçn√≠k, otazn√≠k, z√°vorky atd.
-    **Speci√°ln√≠ znaky:** R≈Øzn√© symboly jako `@`, `&`, `#`, `$` a **mezera** (kter√° m√° k√≥d 32).
-    **≈ò√≠d√≠c√≠ znaky:** Netisknuteln√© znaky s k√≥dy **0 a≈æ 31** a **127**. Tyto znaky slou≈æ√≠ k ovl√°d√°n√≠ za≈ô√≠zen√≠, form√°tov√°n√≠ textu a ≈ô√≠zen√≠ p≈ôenosu dat (nap≈ô. `CR` - Carriage Return, `LF` - Line Feed, `BEL` - Bell).

---

### Rozdƒõlen√≠ k√≥d≈Ø

| Rozsah k√≥d≈Ø   | Typ znak≈Ø                     | P≈ô√≠klad                                          |     |
| :------------ | :---------------------------- | :----------------------------------------------- | --- |
| **0 - 31**    | ≈ò√≠d√≠c√≠ znaky                  | `NUL`, `BEL`, `CR`, `LF`, `ESC`                  |     |
| **32 - 47**   | Mezera, interpunkce a symboly | ` ` (mezera), `!`, `"`, `#`, `$`                 |     |
| **48 - 57**   | ƒå√≠slice                       | `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9` |     |
| **58 - 64**   | Dal≈°√≠ interpunkce a symboly   | `:`, `;`, `<`, `=`, `>`, `?`, `@`                |     |
| **65 - 90**   | Velk√° p√≠smena abecedy         | `A`, `B`, `C`, ..., `Z`                          |     |
| **91 - 96**   | Dal≈°√≠ symboly                 | `[`, `\`, `]`, `^`, `_`, `` ` ``                 |     |
| **97 - 122**  | Mal√° p√≠smena abecedy          | `a`, `b`, `c`, ..., `z`                          |     |
| **123 - 127** | Z√°vorky a ≈ô√≠d√≠c√≠ znak         | `{`, `\|`, `}`, `~`, `DEL`                       |     |

# 7-bitov√Ω ASCII - Pou≈æit√≠ a limity

---

## Ulo≈æen√≠ v pamƒõti üíæ

> [!note] Princip ulo≈æen√≠
> Tabulka ASCII definuje **128 unik√°tn√≠ch znak≈Ø**, co≈æ p≈ôesnƒõ odpov√≠d√° poƒçtu kombinac√≠, kter√© lze vytvo≈ôit pomoc√≠ **7 bit≈Ø** ($2^7 = 128$). Ka≈æd√Ω znak m√° tedy sv≈Øj 7bitov√Ω k√≥d.

V modern√≠ch poƒç√≠taƒç√≠ch, kter√© pracuj√≠ s daty po cel√Ωch bajtech, se k tomuto 7bitov√©mu k√≥du v praxi p≈ôid√°v√° jedna nula na zaƒç√°tek. T√≠m se hodnota ƒç√≠sla nezmƒõn√≠, ale zajist√≠ se, ≈æe ka≈æd√Ω znak je ulo≈æen p≈ôesnƒõ v **jednom bajtu (8 bit≈Ø)**.

**P≈ô√≠klad:** Znak 'A' m√° k√≥d `1000001` (7 bit≈Ø). V pamƒõti se ulo≈æ√≠ jako `01000001` (8 bit≈Ø).

---

## Omezen√≠ pro n√°rodn√≠ jazyky üåç

> [!warning] Nedostateƒçnost pro jin√© jazyky
> Zat√≠mco pro anglicky psan√© texty je 7-bitov√° ASCII tabulka st√°le pou≈æiteln√°, pro vƒõt≈°inu ostatn√≠ch jazyk≈Ø je **zcela nedostateƒçn√°**.

Hlavn√≠m probl√©mem je, ≈æe **neobsahuje p√≠smena s diakritikou**, jako jsou ƒçesk√© h√°ƒçky a ƒç√°rky (`ƒç`, `≈°`, `≈ô`, `√©`, `√°` atd.). To znemo≈æ≈àuje spr√°vn√Ω z√°pis ƒçesk√Ωch a mnoha dal≈°√≠ch text≈Ø. Pr√°vƒõ tento limit vedl k v√Ωvoji 8bitov√Ωch roz≈°√≠≈ôen√≠ a pozdƒõji standardu Unicode.


# 8-bitov√Ω ASCII ‚Äì K√≥dov√© str√°nky

> [!note] Reakce na omezen√≠ 7-bitov√©ho ASCII
> S pot≈ôebou zapisovat texty v n√°rodn√≠ch jazyc√≠ch p≈ôi≈°lo roz≈°√≠≈ôen√≠ 7-bitov√©ho ASCII na **8-bitov√©**. T√≠m se zdvojn√°sobil poƒçet dostupn√Ωch znak≈Ø z 128 na **256**, co≈æ umo≈ænilo p≈ôidat p√≠smena s diakritikou a dal≈°√≠ speci√°ln√≠ symboly.

---

## Princip k√≥dov√Ωch str√°nek

Prvn√≠ch 128 znak≈Ø (k√≥dy 0-127) z≈Østalo stejn√Ωch jako v p≈Øvodn√≠m ASCII standardu. Druh√° polovina tabulky (k√≥dy 128-255) byla vyu≈æita pro n√°rodn√≠ znaky.

> [!warning] Probl√©m: Jedno roz≈°√≠≈ôen√≠ nestaƒç√≠
> Ani 128 nov√Ωch pozic nebylo dostateƒçn√Ωch pro pokryt√≠ v≈°ech znak≈Ø v≈°ech svƒõtov√Ωch jazyk≈Ø. Bylo nemo≈æn√© do jedn√© tabulky um√≠stit nap≈ô√≠klad ƒçeskou diakritiku, azbuku i ≈ôeckou abecedu z√°rove≈à.

Tento probl√©m vedl ke vzniku r≈Øzn√Ωch **k√≥dov√Ωch str√°nek**. Ka≈æd√° k√≥dov√° str√°nka je v podstatƒõ jin√° verze horn√≠ poloviny ASCII tabulky, urƒçen√° pro specifick√Ω jazyk nebo skupinu jazyk≈Ø.

**P≈ô√≠klad k√≥dov√Ωch str√°nek:**
-   **Latin-2 (ISO 8859-2):** Pro jazyky st≈ôedn√≠ a v√Ωchodn√≠ Evropy, vƒçetnƒõ ƒçe≈°tiny.
-   **Windows-1250:** Podobn√° verze od Microsoftu pro stejnou jazykovou oblast.
-   **Windows-1251:** Pro jazyky pou≈æ√≠vaj√≠c√≠ azbuku.

> [!error] D≈Øsledek: Probl√©my s kompatibilitou
> Pokud byl text vytvo≈ôen v jedn√© k√≥dov√© str√°nce (nap≈ô. Windows-1250) a zobrazen na syst√©mu, kter√Ω oƒçek√°val jinou (nap≈ô. standardn√≠ z√°padn√≠ Windows-1252), do≈°lo ke ≈°patn√© interpretaci znak≈Ø. To je p≈ô√≠ƒçinou zn√°m√©ho jevu, kdy se m√≠sto ƒçesk√Ωch znak≈Ø zobrazovaly nesmysln√© symboly ("rozsypan√Ω ƒçaj").

![[Pasted image 20251013134136.png]]
*Uk√°zka horn√≠ poloviny ASCII tabulky v jedn√© z k√≥dov√Ωch str√°nek pro st≈ôedoevropsk√© jazyky.*



# 8-bitov√Ω ASCII ‚Äì Pou≈æit√≠ a k√≥dov√© str√°nky

V dne≈°n√≠ dobƒõ p≈ôeva≈æuje pou≈æ√≠v√°n√≠ dvou hlavn√≠ch skupin k√≥dov√Ωch str√°nek, kter√© roz≈°i≈ôuj√≠ p≈Øvodn√≠ 7-bitov√© ASCII pro pot≈ôeby n√°rodn√≠ch jazyk≈Ø.

---

## Dvƒõ hlavn√≠ skupiny k√≥dov√Ωch str√°nek

> [!note]
> 1.  **ISO 8859-1 a≈æ ISO 8859-16 (LATIN1 ‚Äì LATIN16):** Standardizovan√° sada k√≥dov√Ωch str√°nek, ƒçasto pou≈æ√≠van√° nap≈ô√≠klad v operaƒçn√≠m syst√©mu **Linux**.
> 2.  **Windows 1250 a≈æ Windows 1258:** Sada k√≥dov√Ωch str√°nek definovan√° spoleƒçnost√≠ Microsoft, pou≈æ√≠van√° v operaƒçn√≠m syst√©mu **Windows**. V programech od Microsoftu se tyto str√°nky ƒçasto souhrnnƒõ oznaƒçuj√≠ zkratkou **ANSI**.

---

## Princip a omezen√≠

Ka≈æd√° k√≥dov√° str√°nka je navr≈æena tak, aby obsahovala znaky pot≈ôebn√© pro **jednu specifickou geografickou nebo jazykovou oblast**.

> [!example] P≈ô√≠klady
> -   **ISO 8859-1 (LATIN1):** Urƒçena pro **z√°padoevropsk√© jazyky**, jako je francouz≈°tina, ≈°panƒõl≈°tina, nƒõmƒçina atd.
> -   **ISO 8859-2 (LATIN2)** a **Windows 1250:** Obƒõ tyto k√≥dov√© str√°nky pokr√Ωvaj√≠ v≈°echny znaky pot≈ôebn√© pro **ƒçe≈°tinu**.

> [!error] Kl√≠ƒçov√© probl√©my k√≥dov√Ωch str√°nek
> -   **Nemo≈ænost kombinace:** V jednom textov√©m souboru **nelze pou≈æ√≠t v√≠ce k√≥dov√Ωch str√°nek najednou**. To znemo≈æ≈àuje nap≈ô√≠klad ps√°t ƒçesky a z√°rove≈à pou≈æ√≠vat azbuku v jednom dokumentu.
> -   **Nejednoznaƒçnost k√≥d≈Ø:** V√Ωznam ƒç√≠seln√©ho k√≥du znaku **nen√≠ absolutn√≠**. Stejn√Ω k√≥d (nap≈ô. 230) m≈Ø≈æe v jedn√© k√≥dov√© str√°nce p≈ôedstavovat znak `√¶` a v jin√© `≈°`. To je hlavn√≠ p≈ô√≠ƒçinou chybn√©ho zobrazov√°n√≠ znak≈Ø ("rozsypan√©ho ƒçaje").

# Unicode: Univerz√°ln√≠ znakov√° sada üåç

Unicode vzniklo jako ≈ôe≈°en√≠ probl√©m≈Ø s nekompatibilitou 8-bitov√Ωch k√≥dov√Ωch str√°nek. C√≠lem bylo vytvo≈ôit **jednotn√Ω standard**, kter√Ω by pokryl v≈°echny znaky v≈°ech svƒõtov√Ωch jazyk≈Ø.

> [!success] Kl√≠ƒçov√© vlastnosti Unicode
> - **Univerz√°lnost:** Tabulka Unicode obsahuje znaky **v≈°ech svƒõtov√Ωch jazyk≈Ø** (v souƒçasnosti p≈ôes 140 000 znak≈Ø).
> - **Flexibilita:** V jednom textu nen√≠ probl√©m kombinovat znaky z v√≠ce jazyk≈Ø najednou (nap≈ô. ƒçe≈°tinu, azbuku a japon≈°tinu).

---

## Metody k√≥dov√°n√≠: UTF

Samotn√Ω Unicode p≈ôi≈ôazuje ka≈æd√©mu znaku unik√°tn√≠ ƒç√≠slo (code point). Pro p≈ôevod tohoto ƒç√≠sla do fin√°ln√≠ dvojkov√© podoby se pou≈æ√≠vaj√≠ r≈Øzn√© metody, kter√© se oznaƒçuj√≠ jako **UTF (Unicode Transformation Format)**.

> [!info] Nejbƒõ≈ænƒõj≈°√≠ UTF metody
> - **UTF-8**
> - **UTF-16**
> - **UTF-32**
>
> Volba metody m√° p≈ô√≠m√Ω vliv na to, kolik bajt≈Ø zabere jeden znak v pamƒõti. Pokud je nƒõkde uvedeno pouze obecn√© "Unicode" bez specifikace, ƒçasto se t√≠m mysl√≠ metoda UTF-16.

### Porovn√°n√≠ velikosti reprezentace znaku

| Metoda  | Velikost znaku                        | Kl√≠ƒçov√° vlastnost                                                               |
| :------ | :------------------------------------ | :------------------------------------------------------------------------------ |
| **UTF-8** | **1, 2, 3 nebo 4 bajty** | Velmi efektivn√≠ pro texty s p≈ôevahou anglick√Ωch znak≈Ø (ty zab√≠raj√≠ jen 1 bajt). Nejpou≈æ√≠vanƒõj≈°√≠ na internetu. |
| **UTF-16**| **2 nebo 4 bajty** | Dobr√Ω kompromis pro jazyky s velk√Ωm mno≈æstv√≠m znak≈Ø. Standard v mnoha syst√©mech (nap≈ô. Windows, Java). |
| **UTF-32**| **V≈ædy 4 bajty** | Jednoduch√© zpracov√°n√≠ (ka≈æd√Ω znak m√° stejnou d√©lku), ale pamƒõ≈•ovƒõ nejm√©nƒõ efektivn√≠. |


# Srovn√°n√≠ k√≥dov√°n√≠ textu: Znakov√Ω reperto√°r üî°

Volba metody k√≥dov√°n√≠ textu p≈ô√≠mo urƒçuje, jak√Ω **znakov√Ω reperto√°r** (sadu dostupn√Ωch znak≈Ø) m≈Ø≈æeme v dan√©m textu pou≈æ√≠t. N√°sleduj√≠c√≠ tabulka a popis shrnuj√≠ kl√≠ƒçov√© rozd√≠ly mezi ASCII, k√≥dov√Ωmi str√°nkami a Unicode.

---

### P≈ôehled pokryt√≠ znak≈Ø

| Znakov√° sada                                    | ASCII (Angliƒçtina) | K√≥dov√° str√°nka (Jazyky z jedn√© oblasti) | Unicode (V≈°echny jazyky) |
| :---------------------------------------------- | :----------------: | :------------------------------------: | :---------------------: |
| **Z√°kladn√≠ latinka a symboly** (a-z, A-Z, 0-9, @) | ‚úÖ                 | ‚úÖ                                     | ‚úÖ                      |
| **N√°rodn√≠ diakritika** (√°, √©, ƒç, ≈ô, ≈æ, √ü)         | ‚ùå                 | ‚úÖ                                     | ‚úÖ                      |
| **Znaky ostatn√≠ch jazyk≈Ø** (–ñ, ◊ß, Â≠ó, ÿ®)         | ‚ùå                 | ‚ùå                                     | ‚úÖ                      |

---

### Podrobnƒõj≈°√≠ vysvƒõtlen√≠

#### 1. ASCII üá¨üáß
> [!note]
> Pokr√Ωv√° pouze **z√°kladn√≠ reperto√°r** znak≈Ø pot≈ôebn√Ω pro angliƒçtinu. Obsahuje p√≠smena bez diakritiky, ƒç√≠slice a z√°kladn√≠ symboly. Pro jak√Ωkoli jin√Ω jazyk je nedostateƒçn√Ω.

#### 2. K√≥dov√° str√°nka üá®üáøüá©üá™üá´üá∑
> [!info]
> Roz≈°i≈ôuje ASCII o znaky pot≈ôebn√© pro **specifickou jazykovou nebo geografickou oblast**. Nap≈ô√≠klad k√≥dov√° str√°nka pro st≈ôedn√≠ Evropu (LATIN2) p≈ôid√°v√° ƒçesk√©, slovensk√© a dal≈°√≠ znaky s diakritikou. Jej√≠ limitac√≠ je, ≈æe **neumo≈æ≈àuje kombinovat znaky z r≈Øzn√Ωch oblast√≠** (nap≈ô. ƒçe≈°tinu a azbuku).

#### 3. Unicode 
> [!success]
> Je to **univerz√°ln√≠ standard**, jeho≈æ c√≠lem je pokr√Ωt **v≈°echny znaky v≈°ech souƒçasn√Ωch i historick√Ωch jazyk≈Ø** svƒõta. Umo≈æ≈àuje bezprobl√©movƒõ kombinovat v jednom textu nap≈ô√≠klad latinku, ≈ôeƒçtinu, ƒç√≠nsk√© znaky i emotikony. Dnes je to nejpou≈æ√≠vanƒõj≈°√≠ a doporuƒçovan√Ω standard.



# Pou≈æit√≠ k√≥dov√°n√≠ textu v praxi

Volba k√≥dov√°n√≠ textu se li≈°√≠ v z√°vislosti na aplikaci, operaƒçn√≠m syst√©mu nebo form√°tu souboru. Zde jsou nƒõkter√© bƒõ≈æn√© p≈ô√≠klady.

---

###  Webov√© str√°nky

> [!info]
> Do roku 2007 bylo nejroz≈°√≠≈ôenƒõj≈°√≠m k√≥dov√°n√≠m pro webov√© str√°nky **ASCII**, respektive jeho 8-bitov√° roz≈°√≠≈ôen√≠. Pot√© ho jako dominantn√≠ standard nahradil **Unicode ve variantƒõ UTF-8**, kter√© je dnes nejpou≈æ√≠vanƒõj≈°√≠m k√≥dov√°n√≠m na internetu.

---

###  Microsoft Word

Program Microsoft Word pou≈æ√≠v√° pro ukl√°d√°n√≠ textu standard **Unicode**, ale konkr√©tn√≠ varianta se li≈°√≠ podle form√°tu souboru:

-   **\*.doc (star≈°√≠ form√°t):** Pou≈æ√≠v√° variantu **UTF-16**.
-   **\*.docx (novƒõj≈°√≠ form√°t, od verze 2007):** Pou≈æ√≠v√° modernƒõj≈°√≠ a pamƒõ≈•ovƒõ efektivnƒõj≈°√≠ variantu **UTF-8**.

---

### N√°zvy soubor≈Ø ve Windows

> [!note]
> Operaƒçn√≠ syst√©m **Windows** pou≈æ√≠v√° pro ukl√°d√°n√≠ n√°zv≈Ø soubor≈Ø a slo≈æek k√≥dov√°n√≠ **Unicode ve variantƒõ UTF-16**. To umo≈æ≈àuje pou≈æ√≠vat v n√°zvech soubor≈Ø znaky z r≈Øzn√Ωch jazyk≈Ø bez omezen√≠.

---

### Legacy programy a ANSI

> [!warning] Probl√©my se star≈°√≠mi programy
> ≈òada star≈°√≠ch program≈Ø, a dokonce i nƒõkter√© syst√©mov√© n√°stroje, st√°le jako v√Ωchoz√≠ pou≈æ√≠vaj√≠ star√© **k√≥dov√© str√°nky**.
>
> **P≈ô√≠klad:** Program **Pozn√°mkov√Ω blok (



# K√≥dov√°n√≠ cel√Ωch ƒç√≠sel 

**Cel√° ƒç√≠sla** (ƒç√≠sla s pevnou ≈ô√°dovou ƒç√°rkou) zahrnuj√≠ jak kladn√°, tak i z√°porn√° cel√° ƒç√≠sla. Jejich ulo≈æen√≠ v poƒç√≠taƒçi vy≈æaduje specifick√Ω p≈ô√≠stup, zejm√©na kv≈Øli znam√©nku.

---

## Probl√©m se znam√©nkem

> [!note]
> Bin√°rn√≠ ƒç√≠sla v poƒç√≠taƒçi sama o sobƒõ **nemaj√≠ znam√©nko** (p≈ôedev≈°√≠m `-`). Je proto nutn√© naj√≠t zp≈Øsob, jak p≈ôev√©st cel√° ƒç√≠sla (vƒçetnƒõ z√°porn√Ωch) na p≈ôirozen√° (nez√°porn√°) ƒç√≠sla, kter√° lze reprezentovat pomoc√≠ bit≈Ø.

Tento p≈ôevod se ≈ôe≈°√≠ r≈Øzn√Ωmi metodami (nap≈ô. dvojkov√Ωm dopl≈àkem), kter√© efektivnƒõ mapuj√≠ z√°porn√° ƒç√≠sla do horn√≠ poloviny dostupn√©ho ƒç√≠seln√©ho rozsahu.

---

## Velikost √∫lo≈æi≈°tƒõ a rozsah hodnot 

Podle p≈ôedpokl√°dan√©ho rozsahu hodnot se cel√° ƒç√≠sla ukl√°daj√≠ do k√≥dov√Ωch slov o velikosti **1 a≈æ 4 bajty**. Velikost √∫lo≈æi≈°tƒõ p≈ô√≠mo ovliv≈àuje, jak velk√° ƒç√≠sla lze reprezentovat.

| K√≥dov√© slovo | Rozsah (jen kladn√° / unsigned) | Rozsah (kladn√° i z√°porn√° / signed) |
| :----------- | :----------------------------- | :--------------------------------- |
| **1 byte** | 0 a≈æ 255                       | -128 a≈æ 127                        |
| **2 byte** | 0 a≈æ 65 535                    | -32 768 a≈æ 32 767                  |
| **4 byte** | 0 a≈æ 4 294 967 295             | -2 147 483 648 a≈æ 2 147 483 647    |

> [!info] V≈°imnƒõte si asymetrie
> U z√°porn√Ωch ƒç√≠sel je rozsah v≈ædy o jedno ƒç√≠slo vƒõt≈°√≠ "do m√≠nusu" (nap≈ô. -128 vs +127). To je d√°no t√≠m, ≈æe nula je pova≈æov√°na za kladn√© ƒç√≠slo, co≈æ uvol≈àuje jednu pozici pro z√°pornou stranu.



# Dopl≈àkov√Ω k√≥d

Pro ulo≈æen√≠ **cel√Ωch ƒç√≠sel** (kladn√Ωch i z√°porn√Ωch) se v poƒç√≠taƒç√≠ch nejƒçastƒõji pou≈æ√≠v√° metoda **dopl≈àkov√©ho k√≥du**. Tento zp≈Øsob efektivnƒõ p≈ôev√°d√≠ v≈°echna cel√° ƒç√≠sla na nez√°porn√°, kter√° lze snadno reprezentovat v bin√°rn√≠ soustavƒõ.

---

## Princip vytvo≈ôen√≠ dopl≈àkov√©ho k√≥du

> [!abstract] Pravidla pro p≈ôevod
> Pro p≈Øvodn√≠ ƒç√≠slo **X** a d√©lku k√≥dov√©ho slova **n** (nap≈ô. 8 bit≈Ø) plat√≠:
>
> 1.  Je-li ƒç√≠slo **X kladn√© nebo nula**, k√≥dov√© slovo **X'** je rovno p≈Øvodn√≠mu ƒç√≠slu:
>     $$ X' = X $$
> 2.  Je-li ƒç√≠slo **X z√°porn√©**, k√≥dov√© slovo **X'** se vypoƒç√≠t√° jako:
>     $$ X' = X + 2^n $$
> 3.  V√Ωsledn√© des√≠tkov√© ƒç√≠slo **X'** se n√°slednƒõ p≈ôevede do bin√°rn√≠ soustavy.

---

## P≈ô√≠klad (pro 8bitov√© slovo, n=8)

V tomto p≈ô√≠kladu je $2^n = 2^8 = 256$.

| P≈Øvodn√≠ ƒç√≠slo (X) | V√Ωpoƒçet X' (des√≠tkovƒõ) | K√≥dov√© slovo X' (des√≠tkovƒõ) | K√≥dov√© slovo X' (bin√°rnƒõ) | K√≥dov√© slovo X' (hexadecim√°lnƒõ) |
| :---------------: | :----------------------------- | :------------------------: | :----------------------: | :---------------------------: |
| **0** | `X' = 0`                       | 0                          | `0000 0000`              | `00`                          |
| **53** | `X' = 53`                      | 53                         | `0011 0101`              | `35`                          |
| **-53** | `X' = -53 + 256`               | 203                        | `1100 1011`              | `CB`                          |

> [!info] Kl√≠ƒçov√° vlastnost
> Tento zp≈Øsob k√≥dov√°n√≠ je velmi v√Ωhodn√Ω, proto≈æe aritmetick√© operace (zejm√©na sƒç√≠t√°n√≠ a odƒç√≠t√°n√≠) funguj√≠ stejnƒõ pro kladn√° i z√°porn√° ƒç√≠sla, co≈æ v√Ωraznƒõ zjednodu≈°uje n√°vrh procesor≈Ø.


# Dopl≈àkov√Ω k√≥d ‚Äì Vlastnosti a v√Ωpoƒçet

Dopl≈àkov√Ω k√≥d m√° nƒõkolik kl√≠ƒçov√Ωch vlastnost√≠, kter√© z nƒõj dƒõlaj√≠ efektivn√≠ metodu pro reprezentaci cel√Ωch ƒç√≠sel v poƒç√≠taƒç√≠ch.

---

## Vlastnosti dopl≈àkov√©ho k√≥du

> [!note] Kl√≠ƒçov√© vlastnosti
> -   **Znam√©nkov√Ω bit:** Prvn√≠ bit zleva (nejvy≈°≈°√≠ bit) funguje jako znam√©nkov√Ω bit.
>     -   U **nez√°porn√©ho ƒç√≠sla** (vƒçetnƒõ nuly) je hodnota tohoto bitu **0**.
>     -   U **z√°porn√©ho ƒç√≠sla** je hodnota tohoto bitu **1**.
> -   **Vhodnost pro aritmetiku:** Tento form√°t je navr≈æen tak, aby sƒç√≠t√°n√≠ a odƒç√≠t√°n√≠ fungovalo stejnƒõ pro kladn√° i z√°porn√° ƒç√≠sla, co≈æ zjednodu≈°uje n√°vrh procesor≈Ø.

---

## Doplnƒõk ‚Äì Jak znegovat ƒç√≠slo

Doplnƒõk `d(x)` k ƒç√≠slu `x` je definov√°n jako jeho opaƒçn√° hodnota (negace), tedy `d(x) = -x`. V bin√°rn√≠ soustavƒõ ho z√≠sk√°me praktick√Ωm dvoukrokov√Ωm postupem.

> [!abstract] Postup v√Ωpoƒçtu dopl≈àku (dvojkov√Ω doplnƒõk)
> 1.  **Inverze bit≈Ø (Jedniƒçkov√Ω doplnƒõk):** V bin√°rn√≠m z√°pisu ƒç√≠sla `x` zamƒõn√≠me v≈°echny nuly za jedniƒçky a v≈°echny jedniƒçky za nuly.
> 2.  **P≈ôiƒçten√≠ jedniƒçky:** K v√Ωsledku z prvn√≠ho kroku bin√°rnƒõ p≈ôiƒçteme `1`.

> [!example] P≈ô√≠klad: V√Ωpoƒçet dopl≈àku k ƒç√≠slu 53 (v 8 bitech)
> Chceme naj√≠t reprezentaci pro ƒç√≠slo **-53**.
>
> 1.  **Bin√°rn√≠ z√°pis ƒç√≠sla 53:**
>     `0011 0101`
> 2.  **Krok 1: Inverze bit≈Ø**
>     `1100 1010`
> 3.  **Krok 2: P≈ôiƒçten√≠ jedniƒçky**
>     `1100 1010 + 1 = 1100 1011`
>
> **V√Ωsledek:** `1100 1011` je dvojkov√Ω dopl≈àkov√Ω k√≥d pro ƒç√≠slo **-53**.



# Sƒç√≠t√°n√≠ dvou ƒç√≠sel v dopl≈àkov√©m k√≥du

Velkou v√Ωhodou dopl≈àkov√©ho k√≥du je, ≈æe sƒç√≠t√°n√≠ funguje pro kladn√° i z√°porn√° ƒç√≠sla naprosto stejnƒõ jako standardn√≠ bin√°rn√≠ sƒç√≠t√°n√≠. Proces prob√≠h√° bit po bitu zprava doleva a vyu≈æ√≠v√° p≈ôenosu do dal≈°√≠ho ≈ô√°du.

---

## Princip sƒç√≠t√°n√≠ (bit po bitu)

> [!abstract] Vstupn√≠ data
> Mƒõjme dvƒõ **n-bitov√°** ƒç√≠sla A a B v dopl≈àkov√©m k√≥du:
> -   $A = (a_{n-1} \dots a_1, a_0)$
> -   $B = (b_{n-1} \dots b_1, b_0)$

V√Ωsledn√Ω souƒçet **S** a **p≈ôenosy C** se vypoƒç√≠taj√≠ podle n√°sleduj√≠c√≠ch pravidel:

#### 1. V√Ωpoƒçet p≈ôenosu (Carry)
P≈ôenos $c_{i+1}$ do dal≈°√≠ho sloupce se urƒç√≠ na z√°kladƒõ bit≈Ø $a_i$, $b_i$ a p≈ôenosu z p≈ôedchoz√≠ho sloupce $c_i$.

> [!note] Pravidla pro p≈ôenos
> -   Poƒç√°teƒçn√≠ p≈ôenos **$c_0$ je v≈ædy 0**.
> -   Pro ka≈æd√Ω dal≈°√≠ bit `i` (od 0 do n-1) plat√≠:
>     -   P≈ôenos **$c_{i+1} = 1$**, pokud jsou alespo≈à **dvƒõ** z hodnot ($a_i, b_i, c_i$) rovny 1.
>     -   V opaƒçn√©m p≈ô√≠padƒõ je p≈ôenos **$c_{i+1} = 0$**.

#### 2. V√Ωpoƒçet v√Ωsledn√©ho bitu souƒçtu
V√Ωsledn√Ω bit souƒçtu $s_i$ se vypoƒç√≠t√° jako **XOR** (exkluzivn√≠ souƒçet) t≈ô√≠ bit≈Ø: $a_i, b_i$ a p≈ôenosu $c_i$.

> [!info] Vzorec pro souƒçet
> $$
> s_i = a_i \oplus b_i \oplus c_i
> $$

---

## P≈ô√≠klad: Seƒçten√≠ 5 + (-3) ve 4 bitech

-   **A = 5** ‚Üí `0101`
-   **B = -3** ‚Üí `1101` (dvojkov√Ω doplnƒõk k ƒç√≠slu 3)
-   Oƒçek√°van√Ω v√Ωsledek: **2** ‚Üí `0010`

| Pozice (i) | 3 | 2 | 1 | 0 |
| :--------- | :-: | :-: | :-: | :-: |
| P≈ôenos C | **$c_4=1$** | $c_3=1$ | $c_2=0$ | $c_1=1$ | $c_0=0$ |
| ƒå√≠slo A | | 0 | 1 | 0 | 1 |
| ƒå√≠slo B | | 1 | 1 | 0 | 1 |
| **Souƒçet S**| | **0** | **0** | **1** | **0** |

**Postup:**
1.  **i=0:** `1 + 1 + 0` = `0`, p≈ôenos $c_1=1$.
2.  **i=1:** `0 + 0 + 1` = `1`, p≈ôenos $c_2=0$.
3.  **i=2:** `1 + 1 + 0` = `0`, p≈ôenos $c_3=1$.
4.  **i=3:** `0 + 1 + 1` = `0`, p≈ôenos $c_4=1$.

V√Ωsledn√Ω souƒçet je **`0010`**, co≈æ je spr√°vn√° hodnota ƒç√≠sla 2. P≈ôenos z posledn√≠ho bitu ($c_4$) se p≈ôi sƒç√≠t√°n√≠ v dopl≈àkov√©m k√≥du ignoruje (pokud ne≈ôe≈°√≠me p≈ôeteƒçen√≠).


# Sƒç√≠t√°n√≠ v dopl≈àkov√©m k√≥du: V√Ωsledek a p≈ôeteƒçen√≠ ‚ûï

Po v√Ωpoƒçtu p≈ôenosov√Ωch bit≈Ø ($c_i$) m≈Ø≈æeme sestavit fin√°ln√≠ v√Ωsledek a ovƒõ≈ôit jeho platnost.

---

## V√Ωpoƒçet v√Ωsledn√©ho souƒçtu (S)

[cite_start]V√Ωsledn√Ω bin√°rn√≠ ≈ôetƒõzec $S = (s_{n-1} \dots s_1, s_0)$ z√≠sk√°me tak, ≈æe pro ka≈æd√Ω bit `i` provedeme operaci **XOR** (exkluzivn√≠ souƒçet) mezi odpov√≠daj√≠c√≠mi bity sƒç√≠tanc≈Ø ($a_i, b_i$) a p≈ôenosem z p≈ôedchoz√≠ho ≈ô√°du ($c_i$). [cite: 1]

> [!abstract] Vzorec pro v√Ωpoƒçet bit≈Ø souƒçtu
> $$
> s_i = a_i \oplus b_i \oplus c_i
> $$

---

## Validaƒçn√≠ krit√©rium: Detekce p≈ôeteƒçen√≠ (Overflow) ‚ö†Ô∏è

Ne v≈ædy se v√Ωsledek sƒç√≠t√°n√≠ vejde do dan√©ho poƒçtu bit≈Ø. [cite_start]Tento stav se naz√Ωv√° **p≈ôeteƒçen√≠ (overflow)** a znamen√°, ≈æe v√Ωsledn√© ƒç√≠slo `S` je neplatn√©. [cite: 1] K jeho detekci slou≈æ√≠ validaƒçn√≠ krit√©rium.

> [!important] Pravidlo pro detekci p≈ôeteƒçen√≠
> [cite_start]P≈ôeteƒçen√≠ nastane, pokud se p≈ôenos **do** posledn√≠ho (znam√©nkov√©ho) bitu **li≈°√≠** od p≈ôenosu **z** posledn√≠ho bitu. [cite: 1]
>
> Vypoƒç√≠t√°me hodnotu `v` porovn√°n√≠m dvou posledn√≠ch p≈ôenosov√Ωch bit≈Ø:
> $$
> v = c_n \oplus c_{n-1}
> $$
> Kde:
> [cite_start]-   **$c_{n-1}$** je p≈ôenos *do* posledn√≠ho bitu. [cite: 1]
> [cite_start]-   **$c_n$** je p≈ôenos *z* posledn√≠ho bitu. [cite: 1]
>
> **Vyhodnocen√≠:**
> -   Pokud je **$v = 1$**, do≈°lo k **p≈ôeteƒçen√≠**. [cite_start]V√Ωsledek `S` je neplatn√Ω. [cite: 1]
> [cite_start]-   Pokud je **$v = 0$**, je v√Ωsledek `S` **platn√Ω** a vyjad≈ôuje spr√°vn√Ω souƒçet `A + B`. [cite: 1]

> [!example] P≈ô√≠klad: 4 + 5 ve 4 bitech
> -   **A = 4** ‚Üí `0100`
> -   **B = 5** ‚Üí `0101`
> -   V√Ωsledek sƒç√≠t√°n√≠: `1001` (co≈æ je -7, tedy ≈°patnƒõ)
> -   **P≈ôenosy:**
>     -   $c_3$ (p≈ôenos *do* posledn√≠ho bitu) = 1
>     -   $c_4$ (p≈ôenos *z* posledn√≠ho bitu) = 0
> -   **Validace:** $v = c_4 \oplus c_3 = 0 \oplus 1 = 1$.
> -   **Z√°vƒõr:** Do≈°lo k p≈ôeteƒçen√≠, v√Ωsledek je neplatn√Ω.



# N√°soben√≠ ƒç√≠sla mocninou dvojky (Bitov√Ω posun) 

N√°soben√≠ libovoln√©ho ƒç√≠sla **X** k-tou mocninou dvojky ($2^k$) je v bin√°rn√≠ soustavƒõ velmi efektivn√≠ a rychl√° operace. M√≠sto slo≈æit√©ho aritmetick√©ho v√Ωpoƒçtu se prov√°d√≠ jednoduch√Ωm **bitov√Ωm posunem doleva**.

---

## Princip n√°soben√≠

> [!abstract] Postup
> 1.  Bin√°rn√≠ ≈ôetƒõzec ƒç√≠sla **X** se posune o **k-m√≠st doleva**.
> 2.  Na uvolnƒõn√° m√≠sta zprava se v≈ædy dopln√≠ hodnota **0**.

V√Ωsledkem je ƒç√≠slo **S**, kter√© odpov√≠d√° souƒçinu $S = X \cdot 2^k$.

---

## P≈ô√≠klad: N√°soben√≠ ƒç√≠slem 4 ($k=2$)

> [!example]
> Chceme vyn√°sobit ƒç√≠slo **X** ƒç√≠slem 4, co≈æ je $2^2$. Budeme tedy posouvat o **k=2** m√≠sta doleva.
>
> **P≈Øvodn√≠ ƒç√≠slo X:**
> `... x‚Çô‚Çã‚ÇÇ  x‚Çô‚Çã‚ÇÉ  ...  x‚ÇÇ  x‚ÇÅ  x‚ÇÄ`
>
> **V√Ωsledn√© ƒç√≠slo S (posunuto o 2 m√≠sta doleva):**
> `... x‚Çô‚Çã‚ÇÇ  x‚Çô‚Çã‚ÇÉ  ...  x‚ÇÇ  x‚ÇÅ  x‚ÇÄ  0  0`
>
> P≈Øvodn√≠ bity se posunuly a zprava se doplnily dvƒõ nuly.

> [!info] Proƒç to funguje?
> V bin√°rn√≠ soustavƒõ m√° ka≈æd√Ω bit v√°hu, kter√° je mocninou dvou. Posunem cel√©ho ƒç√≠sla o jednu pozici doleva se v√°ha ka≈æd√©ho bitu zdvojn√°sob√≠, co≈æ odpov√≠d√° n√°soben√≠ dvƒõma. Kdy≈æ tento posun provedeme *k*-kr√°t, v√Ωsledek je stejn√Ω jako n√°soben√≠ ƒç√≠slem $2^k$.

# Dƒõlen√≠ ƒç√≠sla k-tou mocninou dvojky (Bitov√Ω posun) 

Podobnƒõ jako n√°soben√≠, i dƒõlen√≠ ƒç√≠sla **X** k-tou mocninou dvojky ($2^k$) lze v bin√°rn√≠ soustavƒõ prov√©st velmi efektivnƒõ pomoc√≠ **bitov√©ho posunu doprava**. Tento typ posunu se naz√Ωv√° **aritmetick√Ω posun**.

---

## Princip dƒõlen√≠

> [!abstract] Postup
> 1.  Bin√°rn√≠ ≈ôetƒõzec ƒç√≠sla **X** se posune o **k-m√≠st doprava**.
> 2.  Na uvolnƒõn√° m√≠sta zleva se nedopl≈àuj√≠ nuly, ale **stejn√° hodnota, jakou mƒõl p≈Øvodn√≠ nejvy≈°≈°√≠ (znam√©nkov√Ω) bit $x_{n-1}$**. T√≠m je zaji≈°tƒõno zachov√°n√≠ znam√©nka i u z√°porn√Ωch ƒç√≠sel.

V√Ωsledkem operace jsou dvƒõ ƒç√°sti:
-   **D (pod√≠l):** Celoƒç√≠seln√Ω pod√≠l $D = X \text{ div } 2^k$. Tvo≈ô√≠ ho bity, kter√© z≈Østaly po posunu.
-   **M (zbytek):** Zbytek po dƒõlen√≠ $M = X \text{ mod } 2^k$. Tvo≈ô√≠ ho bity, kter√© byly posunem "vysunuty" doprava.

---

## P≈ô√≠klad (pro k=2)

> [!example] Dƒõlen√≠ ƒç√≠slem 4 ($2^2$)
> Chceme vydƒõlit ƒç√≠slo **X** ƒç√≠slem 4, tedy posouv√°me o **k=2** m√≠sta doprava.
>
> **P≈Øvodn√≠ ƒç√≠slo X:**
> `x‚Çô‚Çã‚ÇÅ  x‚Çô‚Çã‚ÇÇ  ...  x‚ÇÇ  x‚ÇÅ  x‚ÇÄ`
>
> **Po posunut√≠ o 2 m√≠sta doprava:**
>
> | P≈Øvodn√≠ bity | `x‚Çô‚Çã‚ÇÅ` | `x‚Çô‚Çã‚ÇÇ` | `...` | `x‚ÇÇ` | `x‚ÇÅ` | `x‚ÇÄ` |
> | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
> | **V√Ωsledn√Ω pod√≠l D** | `x‚Çô‚Çã‚ÇÅ` | `x‚Çô‚Çã‚ÇÅ` | `...` | `x‚Çô‚Çã‚ÇÇ` | `...` | `d‚ÇÄ` |
> | **V√Ωsledn√Ω zbytek M**| | | | | `m‚ÇÅ` | `m‚ÇÄ` |
>
> Zleva se doplnila hodnota p≈Øvodn√≠ho znam√©nkov√©ho bitu $x_{n-1}$. Bity, kter√© z≈Østaly, tvo≈ô√≠ pod√≠l **D**. Bity $x_1$ a $x_0$, kter√© byly vysunuty, tvo≈ô√≠ zbytek **M**.

> [!warning] D≈Øle≈æit√© pro z√°porn√° ƒç√≠sla
> V dopl≈àkov√©m k√≥du tento postup spr√°vnƒõ stanov√≠ v√Ωsledek **celoƒç√≠seln√©ho dƒõlen√≠ (div)** a **zbytku po dƒõlen√≠ (mod)**, co≈æ se pro z√°porn√° ƒç√≠sla m≈Ø≈æe li≈°it od standardn√≠ho matematick√©ho dƒõlen√≠.



# ƒå√≠sla v pohybliv√© ≈ô√°dov√© ƒç√°rce (IEEE 754) üö§

Pro reprezentaci **re√°ln√Ωch ƒç√≠sel** se v poƒç√≠taƒç√≠ch nejƒçastƒõji pou≈æ√≠v√° standardizovan√Ω **form√°t IEEE 754**. Z√°kladn√≠ (32bitov√°, tzv. single-precision) varianta definuje, jak je re√°ln√© ƒç√≠slo `x` ulo≈æeno do 32bitov√©ho k√≥dov√©ho slova `x'`.

> [!abstract] Obecn√Ω tvar ƒç√≠sla
> Ka≈æd√© re√°ln√© ƒç√≠slo je p≈ôevedeno do semilogaritmick√©ho tvaru:
> $$
> x = \pm 1,m \cdot 2^e
> $$
> Kde:
> - **¬±** je znam√©nko.
> - **1,m** je mantisa (normalizovan√° tak, aby byla v≈ædy v intervalu `[1, 2)`).
> - **e** je exponent.

---

## Struktura 32bitov√©ho k√≥dov√©ho slova

32bitov√© slovo je rozdƒõleno do t≈ô√≠ logick√Ωch ƒç√°st√≠, z nich≈æ ka≈æd√° k√≥duje jednu slo≈æku v√Ω≈°e uveden√©ho tvaru.

### 1. Znam√©nko (¬±)
> [!note]
> - **Bit:** 31 (jeden nejvy≈°≈°√≠ bit).
> - **V√Ωznam:**
>    - **0** = nez√°porn√© ƒç√≠slo (+).
>    - **1** = z√°porn√© ƒç√≠slo (-).

### 2. Exponent (e)
> [!info]
> - **Bity:** 30 a≈æ 23 (celkem 8 bit≈Ø).
> - **Rozsah:** Umo≈æ≈àuje reprezentovat exponent `e` z intervalu `(-126; 127)`.
> - **K√≥dov√°n√≠:** Do pamƒõti se neukl√°d√° p≈ô√≠mo exponent `e`, ale jeho posunut√° hodnota `e'` (tzv. k√≥d s posunutou nulou neboli *bias*). Pro 8 bit≈Ø je posun 127.
> - **V√Ωpoƒçet:**
>   $$
>   e' = e + 127
>   $$

### 3. Mantisa (m)
> [!success]
> - **Bity:** 22 a≈æ 0 (celkem 23 bit≈Ø).
> - **V√Ωznam:** Reprezentuje desetinnou (zlomkovou) ƒç√°st ƒç√≠sla.
> - **Princip:** Proto≈æe je ƒç√≠slo v≈ædy normalizov√°no do tvaru `1,m...`, je √∫vodn√≠ jedniƒçka **implicitn√≠** (tzv. *hidden bit*) a do pamƒõti se neukl√°d√°. Ukl√°d√° se pouze ƒç√°st za desetinnou ƒç√°rkou, oznaƒçen√° jako `m'`.
> - **V√Ωpoƒçet hodnoty:** Hodnota mantisy `m` se z ulo≈æen√Ωch bit≈Ø `m' = a‚ÇÇ‚ÇÇ...a‚ÇÄ` vypoƒç√≠t√° jako:
>   $$
>   m = \sum_{i=1}^{23} a_{23-i} \cdot 2^{-i}
>   $$

---

### Rozlo≈æen√≠ bit≈Ø

| Bit        | 31                   | 30                       | ... | 23  | 22                       | ... | 0   |
| :--------- | :------------------- | :----------------------- | :-- | :-- | :----------------------- | :-- | :-- |
| **V√Ωznam** | **Znam√©nko** (1 bit) | **Exponent e'** (8 bit≈Ø) |     |     | **Mantisa m'** (23 bit≈Ø) |     |     |